#Editor Assistant
#Adds some capabilities to the python editor
#as a new task panel dialog
#https://forum.freecadweb.org/viewtopic.php?f=22&t=67242
#2022, <TheMarkster> LGPL2.1 or later
#
#
__title__   = "Editor_Assistant"
__author__  = "TheMarkster"
__url__     = "https://forum.freecadweb.org/viewtopic.php?f=22&t=67242"
__github__  = "https://raw.githubusercontent.com/mwganson/Editor_Assistant/main/Editor_Assistant.FCMacro"
__wiki__    = ""
__version__ = "1.69c"
__date__    = "2022/04/03"
#
UNDO_QUEUE_MAX_SIZE = 100
BOOKMARK_MARKER = "##:"

from PySide import QtGui,QtCore
import difflib
import json
import re
## used for help -> reference menus
import PySide2
from PySide2 import QtNetwork, QtHelp, QtMultimedia, QtOpenGL, QtPrintSupport, \
                    QtSql, QtSvg, QtTest, QtWidgets, QtXml, QtXmlPatterns
import Draft
import DraftUtils
import Fem
import FemGui
import Image
import ImageGui
import Measure
import Mesh
import MeshGui
import MeshPart
import MeshPartGui
import PartDesign
import PartDesignGui
import PartGui
import Path
import PathGui
import PathSimulator
import Points
import PointsGui
import Sketcher
import SketcherGui
import Spreadsheet
import SpreadsheetGui
import TechDraw
import TechDrawGui
import Web
import WebGui

####new
global duplicate_Find   ; duplicate_Find    = []
global duplicate_Replace; duplicate_Replace = []
####new

try:
    import shiboken2 as shiboken
except:
    shiboken = None
mw = FreeCADGui.getMainWindow()


class FindEdit (QtGui.QLineEdit):
    def __init__(self, parent=None, form=None):
        super(FindEdit, self).__init__()
        self.form = form
        self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.__contextMenu)
        self.installEventFilter(self)
        self.setToolTip("Double click to set text from current selection in editor")

    def eventFilter(self, watched, event):
        if watched == self and event.type() == QtCore.QEvent.MouseButtonDblClick:
            if shiboken.isValid(self.form.currentEditor) and self.form.currentEditor:
                sel = self.form.currentEditor.textCursor().selectedText()
                if sel:
                    self.setText(sel)
                else:
                    self.form.toast("Nothing selected in editor","Error")
            else:
                self.form.toast("Editor is invalid","Error")
        return QtGui.QLineEdit.eventFilter(self, watched, event)

    def __contextMenu(self):
        self._normalMenu = self.createStandardContextMenu()
        self._addCustomMenuItems(self._normalMenu)
        self._normalMenu.exec_(QtGui.QCursor.pos())

    def _addCustomMenuItems(self, menu):
        menu.addSeparator()
        action = QtGui.QAction("Use selected", self)
        action.triggered.connect(self.useSelected)
        action.setEnabled(self.form.currentEditor.textCursor().selectedText() != "")
        menu.addAction(action)

        actionClear = QtGui.QAction("Clear", self)
        actionClear.triggered.connect(self.clear)
        actionClear.setEnabled(len(self.text()))
        menu.addAction(actionClear)

        actionHighlight = QtGui.QAction("Highlight",self)
        actionHighlight.triggered.connect(self.highlight)
        actionHighlight.setEnabled(len(self.text()))
        if self == self.form.findEdit:
            menu.addAction(actionHighlight)

    def highlight(self):
        if self == self.form.findEdit:
            self.form.highlightFromFind()

    def clear(self):
        self.setText("")

    def useSelected(self):
        txt_cur = self.form.currentEditor.textCursor()
        txt = txt_cur.selectedText()
        self.setText(txt)

class CustomQWidget(QtGui.QWidget):
    def __init__(self, parent=None, form=None):
        super(CustomQWidget, self).__init__()
        self.form = form
        self.hide()
        self.setAttribute(QtCore.Qt.WA_DeleteOnClose, True)
    def setFound(self,found):
        self.form.found = found

class TaskEditorAssistant:
    def __init__(self):
        #super(TaskEditorAssistant, self).__init__(mw, QtCore.Qt.Tool)
        self.pg = FreeCAD.ParamGet("User parameter:Plugins/Editor_Assistant")
        #GetInt(), SetInt(), GetFloat(), SetFloat(), GetBool(), SetBool(), GetASCII(), SetASCII()
        self.isTabbed=False
        self.found = False #find result
        self.lastHighlightMode = "find" #can be None, "find", or "selection"
        self.gotoLineDict = {} #to save goto line edit value for each editor
        self.editorDict = {}
        self.editors = []
        self.parents = []
        self.grandparents = []
        self.titles = []
        self.templateDictString = self.getTemplateString()
        self.undoQueue = [] #dictionary list {reason, old_text, name, tc}
        self.redoQueue = [] #tc holds a tuple (start, end) of selected text position
        self.snaps = [] #dictionary list {reason, old_text, name, tc}
        self.currentEditor = None
        self.timers = [] #toasts use this
        self.toastsLog = [tuple(["No previous toasts","Message"])]
        self.getEditors()
        self.blockSignals = False
        self.form = CustomQWidget(form=self)
        self.form.setObjectName("Editor assistant")
        self.form.setWindowTitle(" Editor assistant v"+__version__)
        self.form.setWindowIcon(QIconFromXPMString(__icon__))
        #self.form.form = self
        #self.print(f"self.editors = {self.editors}")
        for ed in self.editors:
            self.editorDict [ed.parent().parent().windowTitle()] = ed
        self.mdi = mw.findChild(QtGui.QMdiArea)
        self.mdi.subWindowActivated.connect(self.onSubWindowActivated)
        #self.layout = VBox = main layout (rest are all HBox)
        #topLabelLayout = toast label
        #editorLayout = editor list widget
        #refreshLayout = refresh button + goto menu button + goto line edit
        #gotoLayout = goto home button + goto end button (hidden by default)
        #undoLayout =  undo + pop undos + redo
        #findEditLayout = Find edit + search + search previous
        #replaceEditLayout = Replace edit + replace + replace all
        #indentLayout = unindent button + indent button + Match case checkbox + whole words checkbox
        #snapLayout = snap button + discard button + snap menu + pop button
        #consoleLayout = to console label + console line edit

        self.layout = QtGui.QVBoxLayout()
        self.form.setLayout(self.layout)
        topLabelLayout = QtGui.QHBoxLayout()
        self.mainMenuBtn = QtGui.QPushButton()
        self.mainMenuBtn.setIcon(QIconFromXPMString(__icon__))
        self.mainMenuBtn.setMaximumWidth(32)
        self.mainMenuBtn.setToolTip("Main menu")
        self.mainMenuBtn.clicked.connect(self.onMainMenuBtnClicked)
        topLabelLayout.addWidget(self.mainMenuBtn)
        self.msgBtn = QtGui.QPushButton()
        self.msgBtn.clicked.connect(self.onMsgBtnClicked)
        self.msgBtn.setIcon(QIconFromStandard("SP_FileDialogInfoView"))
        self.msgBtn.setToolTip("Toast message area, click to see most recent message")
        topLabelLayout.addWidget(self.msgBtn)
        self.layout.addLayout(topLabelLayout)

        editorLayout = QtGui.QHBoxLayout()
        showEditorList = self.pg.GetBool("ShowEditorList",True)
        self.editorList = QtGui.QListWidget()
        self.editorList.setMinimumHeight(85)
        self.editorList.currentItemChanged.connect(self.onEditorListCurrentItemChanged)
        self.editorList.doubleClicked.connect(self.onRefreshBtnClicked)
        self.editorList.setToolTip("Open editors, press Refresh to update")
        editorLayout.addWidget(self.editorList)
        if not showEditorList:
            self.editorList.setVisible(showEditorList)
        self.layout.addLayout(editorLayout)
        self.populateList()

        refreshLayout = QtGui.QHBoxLayout()
        showRefreshLine = self.pg.GetBool("ShowRefreshLine", True)
        self.refreshBtn = QtGui.QPushButton("Refresh")
        self.refreshBtn.setToolTip("Refresh list of editors in the list widget above")
        self.refreshBtn.setIcon(QIconFromStandard("SP_BrowserReload"))
        self.refreshBtn.clicked.connect(self.onRefreshBtnClicked)
        refreshLayout.addWidget(self.refreshBtn)
        self.gotoLineEdit = QtGui.QLineEdit()
        self.gotoLineEdit.returnPressed.connect(self.onGotoLineEditReturnPressed)
        self.gotoLineEdit.textChanged.connect(self.onGotoLineEditTextChanged)
        self.gotoLineEdit.setPlaceholderText("Goto Line numbers")
        self.gotoMenuBtn = QtGui.QPushButton()
        self.gotoMenuBtn.setToolTip(f"\
Goto menu\n\
Line numbers = comma separated lines in Goto line edit\n\
Bookmarks = lines with {BOOKMARK_MARKER} bookmark description\n\
Find results = results of searches for text in Find line edit\n\
")
        self.gotoMenuBtn.clicked.connect(self.onGotoMenuBtnClicked)
        self.gotoMenuBtn.setIcon(QIconFromStandard("SP_TitleBarUnshadeButton"))
        refreshLayout.addWidget(self.gotoMenuBtn)
        refreshLayout.addWidget(self.gotoLineEdit)
        self.layout.addLayout(refreshLayout)
        if not showRefreshLine:
            self.refreshBtn.setVisible(showRefreshLine)
            self.gotoMenuBtn.setVisible(showRefreshLine)
            self.gotoLineEdit.setVisible(showRefreshLine)

        gotoLayout = QtGui.QHBoxLayout()
        showGotoLine = self.pg.GetBool("ShowGotoLine",False)
        self.gotoHomeBtn = QtGui.QPushButton("Home")
        self.gotoHomeBtn.clicked.connect(self.onGotoHomeBtnClicked)
        gotoLayout.addWidget(self.gotoHomeBtn)
        self.gotoEndBtn = QtGui.QPushButton("End")
        self.gotoEndBtn.clicked.connect(self.onGotoEndBtnClicked)
        gotoLayout.addWidget(self.gotoEndBtn)
        self.layout.addLayout(gotoLayout)
        if not showGotoLine:
            self.gotoHomeBtn.setVisible(showGotoLine)
            self.gotoEndBtn.setVisible(showGotoLine)

        showUndoLine = self.pg.GetBool("ShowUndoLine",True)
        undoLayout = QtGui.QHBoxLayout()
        self.undoBtn = QtGui.QPushButton()
        self.undoBtn.setEnabled(False)
        undoLayout.addWidget(self.undoBtn)
        self.undoBtn.clicked.connect(self.onUndoBtnClicked)
        self.undoBtn.setIcon(QIconFromXPMString(undo_icon))
        self.undoClearBtn = QtGui.QPushButton()
        self.undoClearBtn.setIcon(QIconFromStandard("SP_DialogResetButton"))
        self.undoClearBtn.setMaximumWidth(48)
        self.undoClearBtn.setToolTip("Purge undo/redo queues.  Clears both queues.")
        self.undoClearBtn.clicked.connect(self.onUndoClearBtnClicked)
        self.undoClearBtn.setEnabled(False)
        undoLayout.addWidget(self.undoClearBtn)
        self.redoBtn = QtGui.QPushButton()
        self.redoBtn.setEnabled(False)
        undoLayout.addWidget(self.redoBtn)
        self.redoBtn.clicked.connect(self.onRedoBtnClicked)
        self.redoBtn.setIcon(QIconFromXPMString(redo_icon))
        self.redoBtn
        if not showUndoLine:
            self.undoBtn.setVisible(showUndoLine)
            self.redoBtn.setVisible(showUndoLine)
            self.undoClearBtn.setVisible(showUndoLine)
        self.layout.addLayout(undoLayout)


        showFindLine = self.pg.GetBool("ShowFindLine",True)
        findEditLayout = QtGui.QHBoxLayout()
        self.findEdit = FindEdit(form=self)
        self.findEdit.setPlaceholderText("Find:")
        self.findEdit.returnPressed.connect(self.onFindEditReturnPressed)
        self.findEdit.textChanged.connect(self.onFindEditTextChanged)
        findEditLayout.addWidget(self.findEdit)
        self.findBtn = QtGui.QPushButton()
        self.findBtn.setIcon(QIconFromXPMString(find_next_icon))
        self.findBtn.setToolTip("Find next\nCtrl+Click = Find from start\nAlt+Click = Find from selection")
        self.findBtn.clicked.connect(self.onFindBtnClicked)
        self.findBackBtn = QtGui.QPushButton()
        self.findBackBtn.setIcon(QIconFromXPMString(find_previous_icon))
        self.findBackBtn.setToolTip("Find previous\nCtrl+Click = Find from end\nAlt+Click = Find from selection")
        self.findBackBtn.clicked.connect(self.onFindBackBtnClicked)
        findEditLayout.addWidget(self.findBtn)
        findEditLayout.addWidget(self.findBackBtn)

####new
        findEditLayout2 = QtGui.QHBoxLayout()
        self.CBox_Find = QtWidgets.QComboBox()
        #self.CBox_Find.setCurrentIndex(4)
        self.CBox_Find.setMaxVisibleItems(16)
        self.CBox_Find.setDuplicatesEnabled(False)    # not work ?
        self.CBox_Find.setEditable(True)              # editable
        QtCore.QObject.connect(self.CBox_Find, QtCore.SIGNAL("currentIndexChanged(QString)"), self.on_CBox_Find)
        findEditLayout2.addWidget(self.CBox_Find)
####new

        if not showFindLine:
            self.findEdit.setVisible(showFindLine)
            self.findBtn.setVisible(showFindLine)
            self.findBackBtn.setVisible(showFindLine)
####new
            self.CBox_Find.setVisible(showFindLine)
####new

        self.layout.addLayout(findEditLayout)

####new
        self.layout.addLayout(findEditLayout2)
####new

        showReplaceLine = self.pg.GetBool("ShowReplaceLine",True)
        replaceEditLayout = QtGui.QHBoxLayout()
        #replaceEditLayout.addWidget(QtGui.QLabel("Replace: "))
        self.replaceEdit = FindEdit(form=self)
        self.replaceEdit.setPlaceholderText("Replace:")
        replaceEditLayout.addWidget(self.replaceEdit)
        self.replaceBtn = QtGui.QPushButton()
        self.replaceBtn.setToolTip("Replace current selection and find next")
        self.replaceBtn.clicked.connect(self.onReplaceBtnClicked)
        self.replaceBtn.setIcon(QIconFromXPMString(replace_icon))
        self.replaceAllBtn = QtGui.QPushButton()
        self.replaceAllBtn.setToolTip("Replace all\nCtrl+Click = Replace only in selection")
        self.replaceAllBtn.setIcon(QIconFromXPMString(replace_all_icon))
        self.replaceAllBtn.clicked.connect(self.onReplaceAllBtnClicked)
        replaceEditLayout.addWidget(self.replaceBtn)
        replaceEditLayout.addWidget(self.replaceAllBtn)

####new
        replaceEditLayout2 = QtGui.QHBoxLayout()
        self.CBox_replaceEdit = QtWidgets.QComboBox()
        #self.CBox_replaceEdit.setCurrentIndex(4)
        self.CBox_replaceEdit.setMaxVisibleItems(16)
        self.CBox_replaceEdit.setDuplicatesEnabled(False)    # not work ?
        self.CBox_replaceEdit.setEditable(True)              # editable
        QtCore.QObject.connect(self.CBox_replaceEdit, QtCore.SIGNAL("currentIndexChanged(QString)"), self.on_CBox_replaceEdit)
        replaceEditLayout2.addWidget(self.CBox_replaceEdit)
####new

        if not showReplaceLine:
            self.replaceEdit.setVisible(showReplaceLine)
            self.replaceBtn.setVisible(showReplaceLine)
            self.replaceAllBtn.setVisible(showReplaceLine)
####new
            self.CBox_replaceEdit.setVisible(showReplaceLine)
####new

        self.layout.addLayout(replaceEditLayout)

####new
        self.layout.addLayout(replaceEditLayout2)
####new

        showIndentLine = self.pg.GetBool("ShowIndentLine", True)
        indentLayout = QtGui.QHBoxLayout()
        self.indentBackBtn = QtGui.QPushButton()
        self.indentBackBtn.setIcon(QIconFromXPMString(unindent_icon))
        self.indentBackBtn.setToolTip("Decrease indentation of selection")
        self.indentBackBtn.clicked.connect(self.onIndentBackBtnClicked)
        indentLayout.addWidget(self.indentBackBtn)
        self.indentBtn = QtGui.QPushButton()
        self.indentBtn.setIcon(QIconFromXPMString(indent_icon))
        self.indentBtn.setToolTip("Increase indentation of selection")
        self.indentBtn.clicked.connect(self.onIndentBtnClicked)
        indentLayout.addWidget(self.indentBtn)
        self.matchWholeCheckBox = QtGui.QCheckBox()
        self.matchWholeCheckBox.setIcon(QIconFromXPMString(match_whole_word_icon))
        self.matchWholeCheckBox.setToolTip("Match whole words")
        self.matchWholeCheckBox.stateChanged.connect(self.onMatchWholeCheckBoxStateChanged)
        self.matchCaseCheckBox = QtGui.QCheckBox()
        self.matchCaseCheckBox.stateChanged.connect(self.onMatchCaseCheckBoxStateChanged)
        self.matchCaseCheckBox.setIcon(QIconFromXPMString(match_case_icon))
        self.matchCaseCheckBox.setToolTip("Match case")
        self.loopCheckBox = QtGui.QCheckBox("Loop")
        self.loopCheckBox.setCheckState(QtCore.Qt.Checked)
        self.loopCheckBox.setToolTip ("Loop to start/end if text not found")
        indentLayout.addWidget(self.matchCaseCheckBox)
        indentLayout.addWidget(self.matchWholeCheckBox)
        indentLayout.addWidget(self.loopCheckBox)
        self.matchCaseCheckBox.stateChanged.connect(self.onFindEditTextChanged)
        if not showIndentLine:
            self.indentBackBtn.setVisible(showIndentLine)
            self.indentBackBtn.setVisible(showIndentLine)
            self.indentBackBtn.setVisible(showIndentLine)
            self.loopCheckBox.setVisible(showIndentLine)
            self.matchCaseCheckBox.setVisible(showIndentLine)
            self.matchWholeCheckBox.setVisible(showIndentLine)
        self.layout.addLayout(indentLayout)

        showSnapsLine = self.pg.GetBool("ShowSnapLine",True)
        snapLayout = QtGui.QHBoxLayout()
        self.takeSnapBtn = QtGui.QPushButton()

        self.takeSnapBtn.setIcon(QIconFromXPMString(snapshot_icon))
        self.takeSnapBtn.setMaximumWidth(48)
        self.takeSnapBtn.setToolTip("Take a snapshot of the text")
        self.snapCenterBtn = QtGui.QPushButton()

        self.snapMenuBtn = QtGui.QPushButton()

        snapCenterBtnLayout = QtGui.QHBoxLayout()
        snapCenterBtnLayoutMargins = QtCore.QMargins(0,0,0,0)
        snapCenterBtnLayout.setContentsMargins(snapCenterBtnLayoutMargins)
        snapCenterBtnLayout.setSpacing(0)
        self.snapCenterBtn.setLayout(snapCenterBtnLayout)
        self.snapCenterBtn.setMaximumWidth(64)
        self.discardSnapBtn = QtGui.QPushButton()

        self.discardSnapBtn.setIcon(QIconFromStandard("SP_DialogResetButton"))
        self.discardSnapBtn.clicked.connect(self.discardSnap)
        self.discardSnapBtn.setToolTip("Discard the latest snap")
        snapCenterBtnLayout.addWidget(self.discardSnapBtn)
        snapCenterBtnLayout.addWidget(self.snapMenuBtn)
        self.snapMenuBtn.setIcon(QIconFromStandard("SP_TitleBarUnshadeButton"))
        self.snapMenuBtn.setToolTip("\
Snapshots menu\n\
Restore = replace current text with snap and keep snap\n\
Restore to clipboard and keep snap in memory\n\
Restore to Text document and keep snap in memory\n\
Restore any = Possibility to restore to different document or a snap out of order\n\
Save to new text file and keep snap in memory\n\
Save all snaps to JSON file and keep all in memory\n\
Load = load all snaps from JSON file, replacing any in memory\n\
Pop = restore and discard snap\n\
Diff = show difference between snap and current text\n\
")
        self.popSnapBtn = QtGui.QPushButton("Restore")
        self.popSnapBtn.setVisible(showSnapsLine)
        self.takeSnapBtn.clicked.connect(self.onTakeSnapBtnClicked)
        self.snapMenuBtn.clicked.connect(self.onSnapMenuBtnClicked)
        self.popSnapBtn.clicked.connect(self.onPopSnapBtnClicked)
        snapLayout.addWidget(self.takeSnapBtn)
        snapLayout.addWidget(self.snapCenterBtn)
        snapLayout.addWidget(self.popSnapBtn)
        #self.snapMenuBtn.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        #self.snapMenuBtn.customContextMenuRequested.connect(self.snapMenuBtnContextMenu)
        self.layout.addLayout(snapLayout)
        if not showSnapsLine:
            self.takeSnapBtn.setVisible(showSnapsLine)
            self.snapCenterBtn.setVisible(showSnapsLine)
            self.discardSnapBtn.setVisible(showSnapsLine)
            self.snapMenuBtn.setVisible(showSnapsLine)

        showConsoleLine = self.pg.GetBool("ShowConsoleLine", True)
        consoleLayout = QtGui.QHBoxLayout()
        self.consoleLabel = QtGui.QLabel("To console:")

        consoleLayout.addWidget(self.consoleLabel)
        self.consoleEdit = QtGui.QLineEdit()

        self.consoleEdit.returnPressed.connect(self.onConsoleEditReturnPressed)
        self.consoleEdit.setToolTip("Access QPlainTextEdit of current editor directly.\n\
Enter command here and press return\n\
Variable 'editor' will remain afterwards for direct access from the console.\n\
Type 'help(editor)' in the console for help.\n\
")
        self.consoleEdit.setText("editor.selectAll()")
        self.consoleSendBtn = QtGui.QPushButton("Send")
        self.consoleSendBtn.clicked.connect(self.onConsoleBtnClicked)
        consoleLayout.addWidget(self.consoleEdit)
        #consoleLayout.addWidget(self.consoleSendBtn)
        self.layout.addLayout(consoleLayout)
        if not showConsoleLine:
            self.consoleLabel.setVisible(showConsoleLine)
            self.consoleEdit.setVisible(showConsoleLine)
        self.updateSnapBtns()

    def getEditors(self):
        self.editors = [child for child in mw.findChildren(QtGui.QPlainTextEdit) if child.objectName() != "Python console"]
        self.parents = [ed.parent() for ed in self.editors]
        self.grandparents = [p.parent() for p in self.parents]
        self.titles = [g.windowTitle() for g in self.grandparents]
        if hasattr(self, "editorList") and shiboken.isValid(self.editorList):
            curNames = [self.editorList.item(ii).text() for ii in range(0, self.editorList.count())]
            for ii,title in enumerate(self.titles):
                if not title in curNames:
                    cursor = self.editors[ii].textCursor()
                    self.takeSnap(title, cursor, "Auto snapshot",self.editors[ii].toPlainText())
        else:
            for ii,title in enumerate(self.titles):
                cursor = self.editors[ii].textCursor()
                self.takeSnap(title, cursor, "Auto snapshot",self.editors[ii].toPlainText())

    def highlightFromSelection(self):
        editor = self.currentEditor
        if not editor:
            self.toast("No editor","Error")
            return
        txt = self.currentEditor.textCursor().selectedText()
        if not txt:
            self.toast("Nothing selected","Error")
            return
        self.lastHighlightMode = "selection"
        self.highlight(txt)

    def highlightFromFind(self):
        editor = self.currentEditor
        if not editor:
            self.toast("No editor","Error")
            return
        txt = self.findEdit.text()
        self.lastHighlightMode = "find"
        self.highlight(txt)

    def highlight(self, txt, color="aqua"):
        """highlight occurrences of txt with background color"""
        if not self.currentEditor:
            self.toast("No current editor","Error")
            return
        if not txt:
            return
        plainText = self.currentEditor.toPlainText()
        cursor = self.currentEditor.textCursor()
        start,end = self.getTC(cursor)
        self.setModified(self.editorList.currentItem().text(), plainText, f"highlight {txt}", self.getTC(cursor))
        indices = self.reFindIndices(plainText, txt, 0)
        extraSelections = []
        count = len(indices)
        for ind in indices:
            extraSelection = QtGui.QTextEdit.ExtraSelection()
            extraSelection.cursor = self.currentEditor.textCursor()
            extraSelection.cursor.setPosition(ind[0])
            extraSelection.cursor.setPosition(ind[1], QtGui.QTextCursor.KeepAnchor)
            extraSelection.format.setBackground(QtGui.QColor(color))
            extraSelections.append(extraSelection)

        self.currentEditor.setExtraSelections(extraSelections)
        self.toast(f"Highlighted {count} occurrences of {txt}","Message")

    def setCurrentEditor(self, name="", focus=True):
        if not shiboken.isValid(self.editorList):
            return
        if name:
            if not name in self.editorDict:
                self.getEditors()
            self.currentEditor = self.editorDict[name]
            if name in self.titles:
                self.blockSignals=True
                self.editorList.setCurrentRow(self.titles.index(name))
                self.blockSignals=False
        else:
            if self.editorList.currentItem():
                name = self.editorList.currentItem().text()
                self.currentEditor = self.editorDict[name]
        if shiboken and shiboken.isValid(self.currentEditor) and self.currentEditor and not self.currentEditor.hasFocus():
            if focus and self.form.parent():
                self.form.parent().hide()
                self.currentEditor.setFocus()
                self.form.parent().show()
        #self.print(f"Current editor: {name}, text = {self.currentEditor.toPlainText()}")
    def onSubWindowActivated(self, arg1):
        if not shiboken.isValid(self.editorList):
            return
        sub = self.mdi.activeSubWindow()
        ed = sub.findChild(QtGui.QPlainTextEdit) if sub else None
        if ed:
            p = ed.parent()
            gp = p.parent()
            name = gp.windowTitle()
            if not name in self.editorDict:
                QtCore.QTimer().singleShot(50, self.refresh)

    def refresh(self):
        self.onRefreshBtnClicked(True)
        #self.getEditors()
        #cur = self.mdi.currentSubWindow()
        #ed = cur.findChild(QtGui.QPlainTextEdit) if cur else None
        #if ed:
        #    p = ed.parent()
        #    gp = p.parent()
        #    curName = gp.windowTitle()
        #    self.setCurrentEditor(curName)

    def checkForTabs(self):
        txt = self.getText()
        if txt.count("\t") > 0:
            self.toast(f"{self.editorList.currentItem().text()}: contains tabs.","Warning")

    def onEditorListCurrentItemChanged(self, current, previous):
        if self.blockSignals:
            return
        self.onRefreshBtnClicked(True)
        self.currentEditor.setFocus()
        if not self.currentEditor.hasFocus():
            self.toast(f"cannot set focus on {self.editorList.currentItem().text()}","Warning")
        self.checkForTabs()
        self.onFindEditTextChanged(None)
        self.updateUndoBtn()
        self.updateSnapBtns()
        name = self.editorList.currentItem().text() if self.editorList.currentItem() else ""
        if name:
            if name in self.gotoLineDict:
                self.gotoLineEdit.setText(self.gotoLineDict[name])
            else:
                self.gotoLineEdit.setText("")

    def doCommand(self, cmd):
        FreeCADGui.doCommand(cmd)

    def setText(self, name, txt, reason):
        old_text = self.getText(name)
        old_cursor = self.editorDict[name].textCursor()
        self.editorDict[name].setPlainText(txt)
        self.setModified(name, old_text, reason, self.getTC(old_cursor))

    def getTC(self, text_cursor):
        return tuple([text_cursor.selectionStart(), text_cursor.selectionEnd()])

    def setTextCursor(self, name, tc):
        ed = self.editorDict[name]
        text_cursor = ed.textCursor()
        text_cursor.setPosition(tc[0])
        text_cursor.setPosition(tc[1], QtGui.QTextCursor.KeepAnchor)
        ed.setTextCursor(text_cursor)

    def getText(self, name=None):
        if not name:
            self.onRefreshBtnClicked(True)
            if not self.editorList.currentItem():
                self.toast("No editor","Error")
                return ""
            else:
                name = self.editorList.currentItem().text()
        return self.editorDict[name].toPlainText() if name in self.editorDict else ""

    def filterBackSlashes(self, instring):
            txt = instring.replace('\\t',chr(9)).replace('\\n',chr(10)).replace('\\r',chr(13))
            txt = txt.replace('\\b',chr(8)).replace('\\f',chr(12)).replace('\'',chr(39))
            txt = txt.replace('\\',chr(92))
            return txt

    def replace(self, name, txt, newTxt):
        """replace txt with newTxt in editor name"""
        #only used by replace all
        if not txt:
            self.toast("nothing to replace","Error")
            return
        inSelectionOnly = False
        modifiers = QtGui.QGuiApplication.keyboardModifiers()
        if modifiers & QtCore.Qt.ControlModifier:
            inSelectionOnly = True
        if not inSelectionOnly:
            fullText = self.getText(name)
        else:
            fullText = self.currentEditor.textCursor().selectedText()
        txt = self.filterBackSlashes(txt)
        indices = self.reFindIndices(fullText, txt, 0)
        chunks = []
        last = -1
        for i in reversed(indices):
            chunks.insert(0, fullText[i[1]:last])
            chunks.insert(0, newTxt)
            last = i[0]
        chunks.insert(0, fullText[:last])
        newText = "".join(chunks)
        count = len(indices)
        self.toast(f"{count} instances of {txt} replaced in {name}","Message")
        if not count == 0:
            if not inSelectionOnly:
                self.setText(name, newText, f"replace {txt}")
            else:
                self.setModified(name,self.currentEditor.toPlainText(), "Replace in selection",self.getTC(self.currentEditor.textCursor()))
                self.currentEditor.textCursor().insertText(newText)

    def reFindIndices(self, plainText, txt, searchFrom = 0):
        """replaces plainText.find(txt, searchFrom=0) with same find using re
           respecting states of match case checkbox and whole words checkbox
            returns list of tuples[(idx, idx2),(idx, idx2),...]"""
        flags = 0 if self.matchCaseCheckBox.checkState() else re.IGNORECASE
        compiled = re.compile("\\b"+txt+"\\b", flags=flags) if self.matchWholeCheckBox.checkState() else re.compile(txt, flags=flags)
        reIter = compiled.finditer(plainText, pos=searchFrom)
        indices = []
        for ii, match in enumerate(reIter):
            indices.append(match.span())
        return indices

    def onMatchCaseCheckBoxStateChanged(self, arg1):
        if self.lastHighlightMode == "selection":
            self.highlightFromSelection()
        elif self.lastHighlightMode == "find":
            self.highlightFromFind()

    def onMatchWholeCheckBoxStateChanged(self, arg1):
        if self.lastHighlightMode == "selection":
            self.highlightFromSelection()
        elif self.lastHighlightMode == "find":
            self.highlightFromFind()

    def find(self, name, txt, backward = False):
        self.setCurrentEditor()
        if not self.currentEditor:
            self.toast("No editor selected")
            return
        if not txt:
            self.toast("Nothing to find.")
            return
        str1 = "'"
        findFlagsList = []

        if self.matchCaseCheckBox.checkState():
            findFlagsList.append("QtGui.QTextDocument.FindFlag.FindCaseSensitively")
        if self.matchWholeCheckBox.checkState():
            findFlagsList.append("QtGui.QTextDocument.FindFlag.FindWholeWords")
        if backward:
            findFlagsList.append("QtGui.QTextDocument.FindFlag.FindBackward")
        if findFlagsList:
            str1 = "', "
            findFlags = "|".join(findFlagsList)
        else:
            findFlags = ""
        newtxt = txt.replace('"', '\\"').replace("'","\\'")
        #self.currentEditor.find(txt, flags)
        #self.toast(f"self.currentEditor.find({txt},{flags})", "Message",10000)

        cmd = """
from PySide import QtGui
__editors__ = [child for child in FreeCADGui.getMainWindow().findChildren(QtGui.QPlainTextEdit)]
__parents__ = [ed.parent() for ed in __editors__]
__grandparents__ = [p.parent().windowTitle() for p in __parents__]
__editor__ = __editors__[__grandparents__.index('""" + name + """')]
__dlg__ = Gui.getMainWindow().findChild(QtGui.QWidget,"Editor assistant")
__dlg__.setFound(__editor__.find('""" + newtxt + str1 + findFlags + """))
__editor__.centerCursor()

del(__editors__, __parents__, __grandparents__, __editor__,__dlg__)

"""

        self.doCommand(cmd)

    def qSearch(self,txt):
        qText = txt.replace(" ","+")
        queryUrl = f"https://doc-snapshots.qt.io/qtforpython/search.html?q={qText}"
        import webbrowser
        webbrowser.open_new_tab(queryUrl)

    def search(self,txt):
        """do a search for txt on github FreeCAD repo"""
        import webbrowser
        qText = txt.replace(" ","+")
        queryUrl = f"https://github.com/FreeCAD/FreeCAD/search?q={qText}"
        webbrowser.open_new_tab(queryUrl)

    def onMsgBtnClicked(self, arg1):
        self.toast("Toast log sent to report view","Information",log=False)
        self.print("Toasts log:\n")
        for ii,toast in enumerate(self.toastsLog):
            if ii==0:
                continue
            self.print(f"{ii}) {toast[0]}",toast[1])

    def onConsoleEditReturnPressed(self):
        self.onConsoleBtnClicked(True)

    def toast(self,msg,msgType='Error',length=5000,log=True,priority="high"):
        if not hasattr(self, "msgBtn") or not shiboken.isValid(self.msgBtn):
            return
        self.timers.append(msg)
        if priority == "high" or not self.msgBtn.text():
            self.msgBtn.setText(msg)
        if log:
            self.toastsLog.append(tuple([msg, msgType]))
        if msgType == 'Error':
            self.msgBtn.setStyleSheet("color: red")
            self.msgBtn.setIcon(QIconFromStandard("SP_MessageBoxCritical"))
        elif msgType == 'Message':
            self.msgBtn.setStyleSheet("color:black")
        elif msgType == 'Warning':
            self.msgBtn.setStyleSheet("color:yellow;background-color:navy;font-weight:bold")
            self.msgBtn.setIcon(QIconFromStandard("SP_MessageBoxWarning"))
        elif msgType == 'Information':
            self.msgBtn.setStyleSheet("color:blue")
            self.msgBtn.setIcon(QIconFromStandard("SP_FileDialogInfoView"))
        QtCore.QTimer().singleShot(length,self.clearToast)

    def clearToast(self):
        #in case there are new messages we don't want to delete them yet, let their timers do it later
        if not shiboken.isValid(self.msgBtn) or not self.form or not self.form.parent():
            return
        if len(self.timers) == 1:
            self.msgBtn.setText("")
            self.msgBtn.setStyleSheet("color:black")
            self.msgBtn.setIcon(QIconFromStandard("SP_FileDialogInfoView"))
            self.timers.pop()
        elif len(self.timers) > 1:
            self.timers.pop()
        #self.mainMenuBtn.show()
        #self.form.resize(self.form.parent().layout().closestAcceptableSize(self.form.parent(), QtCore.QSize(0,0)))
        #self.form.resize(self.form.layout().closestAcceptableSize(self.form, QtCore.QSize(0,0)))

    def onConsoleBtnClicked(self, arg1):
        self.onRefreshBtnClicked(True)
        consoleCmd = self.consoleEdit.text()
        consoleCmd = consoleCmd.replace("help(", "dlg.showHelp(")
        consoleCmd = consoleCmd.replace("menu(","dlg.makeReferenceMenu(")
        consoleCmd = consoleCmd.replace("search(", "dlg.search(")
        consoleCmd = consoleCmd.replace("qSearch(", "dlg.qSearch(")
        consoleCmd = consoleCmd.replace("\\n",chr(10))
        name = self.editorList.currentItem().text() if self.editorList.currentItem() else ""
        if not name:
            self.toast("No editor selected")
        if name:
            old_text = self.getText(name)
            old_cursor = self.editorDict[name].textCursor()
            cmd = """
from PySide import QtGui
__editors__ = [child for child in FreeCADGui.getMainWindow().findChildren(QtGui.QPlainTextEdit)]
__parents__ = [ed.parent() for ed in __editors__]
__grandparents__ = [p.parent().windowTitle() for p in __parents__]
editor = __editors__[__grandparents__.index('""" + name + """')]
dlg = Gui.getMainWindow().findChild(QtGui.QWidget,"Editor assistant").form
"""+ consoleCmd + """
del(__editors__, __parents__, __grandparents__)
"""
        else: #not name
            if consoleCmd.startswith("editor"):
                self.toast("No open editor","Error")
                return
            cmd = """
from PySide import QtGui
dlg = Gui.getMainWindow().findChild(QtGui.QWidget,"Editor assistant").form
"""+ consoleCmd + """
"""
        self.doCommand(cmd)
        if name:
            if not old_text == self.getText():
                self.setModified(name, old_text, "Console command", self.getTC(old_cursor))
            self.toast("editor now available as variable in python console","Message")
        pyconsole = mw.findChild(QtGui.QPlainTextEdit,"Python console")
        pyconsole.setFocus()
        self.form.parent().hide()
        pyconsole.parent().show()
        self.form.parent().show()

    def onFindEditReturnPressed(self):
        self.onFindBtnClicked(True)

####new
    def on_CBox_Find(self,text):
        global duplicate_Find

        if text not in duplicate_Find:
            duplicate_Find.append(text)
            duplicate_Find = sorted(list(set(duplicate_Find))) # sort
            self.CBox_Find.addItem(text)
        self.CBox_Find.setCurrentText(text)
        self.findEdit.setText(text)
####new

    def onFindEditTextChanged(self, arg1):
        matchCase = self.matchCaseCheckBox.checkState()
        if not shiboken.isValid(self.currentEditor) or not self.currentEditor:
            self.toast("current editor is invalid", "Error")
            return
        plainText = self.currentEditor.toPlainText()
        txt = self.filterBackSlashes(self.findEdit.text())
        if not matchCase:
            plainText = plainText.lower()
            txt = txt.lower()
        name = self.editorList.currentItem().text() if self.editorList.currentItem() else ""
        count = plainText.count(txt)
        if name and txt:
            self.toast(f"{txt} count in {name}: {count}","Message")
        if self.lastHighlightMode == "find":
            self.highlightFromFind()

    def onFindBtnClicked(self, arg1=True):
        self.onRefreshBtnClicked(True)
        if not shiboken.isValid(self.currentEditor) or not self.currentEditor:
            self.toast("current editor is invalid","Error")
            return
        self.currentEditor.setFocus()
        name = self.editorList.currentItem().text()
        txt = self.findEdit.text()
        matchCase = self.matchCaseCheckBox.checkState()
        modifiers = QtGui.QApplication.keyboardModifiers()
        if modifiers & QtCore.Qt.AltModifier:
            selText = self.currentEditor.textCursor().selectedText()
            self.findEdit.setText(selText if selText else txt)
            txt = self.findEdit.text()
        if modifiers & QtCore.Qt.ControlModifier:
            self.gotoLine(1, silent=True)

        self.found = False
        self.find(name, txt)
        if not self.found:
            if self.loopCheckBox.checkState():
                self.toast(f"{txt} not found in {name} --Looping back to start","Warning")
                self.gotoLine(1, silent=True)
        self.on_CBox_Find(txt)

    def updateSnapBtns(self,refresh=True):
        if refresh:
            self.onRefreshBtnClicked(True)
        if not hasattr(self, "editorList"):
            return
        curName = self.editorList.currentItem().text() if self.editorList.count() else None
        snaps = [snap for snap in reversed(self.snaps) if snap["name"] == curName]
        if not snaps:
            self.popSnapBtn.setEnabled(False)
            self.popSnapBtn.setText("Pop")
            self.popSnapBtn.setToolTip("Pop/restore and discard latest snap")
            self.discardSnapBtn.setEnabled(False)
        else:
            self.popSnapBtn.setEnabled(True)
            self.popSnapBtn.setText(f"Pop {snaps[0]['reason']}")
            self.popSnapBtn.setToolTip(f"Pop/restore and discard {snaps[0]['reason']}")
            self.discardSnapBtn.setEnabled(True)

    def takeSnap(self, curName, curCursor=None, reason="", plainText=""):
        """takeSnap(curName, curCursor=None, reason="")
           if not curCursor it is taken from current editor
           if not reason it is Snap #NNN"""
        curText = self.getText(curName) if not plainText else plainText
        curCursor = self.currentEditor.textCursor() if not curCursor else curCursor
        tc = self.getTC(curCursor)
        count = 1
        for snap in self.snaps:
            if snap["name"] == curName:
                count += 1
        if reason:
            thisReason = reason
        else:
            thisReason = f"Snap #{count}"
        thisSnap = {"name":curName, "old_text":curText, "reason":thisReason, "tc":tc}
        self.snaps.append(thisSnap)
        self.toast(f"{thisSnap['reason']} taken of {curName}","Message")
        if len(self.snaps) > UNDO_QUEUE_MAX_SIZE:
            self.snaps.pop(0)
            self.toast("Snaps count exceeds {UNDO_QUEUE_MAX_SIZE}, discarding oldest snap","Warning")
        self.updateSnapBtns(refresh=False)

    def onTakeSnapBtnClicked(self, arg1):
        self.onRefreshBtnClicked(True)
        self.updateSnapBtns()
        curName = self.editorList.currentItem().text() if self.editorList.count() else ""
        if not curName:
            self.toast("No current editor","Error")
            return
        self.takeSnap(curName)

    def getSnaps(self):
        self.onRefreshBtnClicked(True)
        curName = self.editorList.currentItem().text() if self.editorList.currentItem() else ""
        snaps = [snap for snap in reversed(self.snaps) if snap["name"] == curName]
        return snaps

    def discardSnap(self,idx=0):
        """discard a snap, default=0 = latest snap"""
        snaps = self.getSnaps()
        if not snaps:
            self.toast("No snaps to discard for this editor","Error")
            self.updateSnapBtns()
            return
        else:
            self.snaps.remove(snaps[idx])
            self.updateSnapBtns()

    def discardAllSnaps(self):
        self.onRefreshBtnClicked(True)
        self.snaps = []
        self.updateSnapBtns()

    def onPopSnapBtnClicked(self, arg1):
        self.onRefreshBtnClicked(True)
        curName = self.editorList.currentItem().text()
        snaps = [snap for snap in reversed(self.snaps) if snap["name"] == curName]
        if not snaps:
            self.toast("No snaps to restore for this editor","Error")
            self.updateSnapBtns()
            return
        else:
            old_text = self.getText(curName)
            old_cursor = self.currentEditor.textCursor()
            self.currentEditor.setPlainText(snaps[0]["old_text"])
            #self.currentEditor.setTextCursor(snaps[0]['tc'])
            self.setTextCursor(self.editorList.currentItem().text(), snaps[0]['tc'])
            self.snaps.remove(snaps[0])
            self.updateSnapBtns()
            self.toast(f"Popped and restored {snaps[0]['reason']} to {snaps[0]['name']}","Message")
            self.setModified(curName, old_text, f"Pop {snaps[0]['reason']}", self.getTC(old_cursor))

    def showWidgets(self,groupName,show):
        showDict = {
            "ShowEditorList": [self.editorList],
            "ShowRefreshLine": [self.refreshBtn, self.gotoMenuBtn, self.gotoLineEdit],
            "ShowGotoLine": [self.gotoEndBtn, self.gotoHomeBtn],
            "ShowUndoLine": [self.undoBtn, self.undoClearBtn, self.redoBtn],
            "ShowFindLine": [self.findEdit, self.findBtn, self.findBackBtn],
            "ShowReplaceLine": [self.replaceEdit, self.replaceBtn, self.replaceAllBtn],
            "ShowIndentLine": [self.indentBackBtn, self.indentBtn, self.matchCaseCheckBox, \
                                self.matchWholeCheckBox, self.loopCheckBox],
            "ShowSnapsLine": [self.takeSnapBtn, self.discardSnapBtn, self.snapCenterBtn, self.snapMenuBtn, self.popSnapBtn],
            "ShowConsoleLine": [self.consoleLabel, self.consoleEdit]
            }
        for widget in showDict[groupName]:
            widget.setVisible(show)

    def setBool(self, name, value):
        self.pg.SetBool(name,value)
        self.showWidgets(name,value)

    def onMainMenuBtnClicked(self, arg1):
        """general purpose menu for things not related to going to a line
           or managing snaps or diffs"""

        def makeToggler(name,value): return lambda: self.setBool(name,value)

#begin settings menu
        showEditorList = self.pg.GetBool("ShowEditorList", True)
        showRefreshLine = self.pg.GetBool("ShowRefreshLine", True)
        showGotoLine = self.pg.GetBool("ShowGotoLine", False)
        showUndoLine = self.pg.GetBool("ShowUndoLine", True)
        showFindLine = self.pg.GetBool("ShowFindLine", True)
        showReplaceLine = self.pg.GetBool("ShowReplaceLine", True)
        showIndentLine = self.pg.GetBool("ShowIndentLine", True)
        showSnapsLine = self.pg.GetBool("ShowSnapsLine", True)
        showConsoleLine = self.pg.GetBool("ShowConsoleLine", True)

        mainMenu = QtGui.QMenu("Main menu")
        settingsMenu = QtGui.QMenu("Settings")
        layoutMenu = QtGui.QMenu("Layout")
        settingsMenu.addMenu(layoutMenu)

        togglers = []

#settings -> layout
        editorListAction = QtGui.QAction("Editor list", layoutMenu, checkable=True)
        editorListAction.setChecked(showEditorList)
        togglers.append(makeToggler("ShowEditorList",not editorListAction.isChecked()))
        editorListAction.toggled.connect(togglers[-1])
        layoutMenu.addAction(editorListAction)

        refreshLineAction = QtGui.QAction("Refresh line",layoutMenu, checkable=True)
        refreshLineAction.setChecked(showRefreshLine)
        togglers.append(makeToggler("ShowRefreshLine", not refreshLineAction.isChecked()))
        refreshLineAction.toggled.connect(togglers[-1])
        layoutMenu.addAction(refreshLineAction)

        gotoLineAction = QtGui.QAction("Goto line",layoutMenu, checkable=True)
        gotoLineAction.setChecked(showGotoLine)
        togglers.append(makeToggler("ShowGotoLine", not gotoLineAction.isChecked()))
        gotoLineAction.toggled.connect(togglers[-1])
        layoutMenu.addAction(gotoLineAction)


        undoLineAction = QtGui.QAction("Undo line", layoutMenu, checkable=True)
        undoLineAction.setChecked(showUndoLine)
        togglers.append(makeToggler("ShowUndoLine", not undoLineAction.isChecked()))
        undoLineAction.toggled.connect(togglers[-1])
        layoutMenu.addAction(undoLineAction)

        findLineAction = QtGui.QAction("Find line", layoutMenu, checkable=True)
        findLineAction.setChecked(showFindLine)
        togglers.append(makeToggler("ShowFindLine", not findLineAction.isChecked()))
        findLineAction.toggled.connect(togglers[-1])
        layoutMenu.addAction(findLineAction)

        replaceLineAction = QtGui.QAction("Replace line", layoutMenu, checkable=True)
        replaceLineAction.setChecked(showReplaceLine)
        togglers.append(makeToggler("ShowReplaceLine", not replaceLineAction.isChecked()))
        replaceLineAction.toggled.connect(togglers[-1])
        layoutMenu.addAction(replaceLineAction)

        indentLineAction = QtGui.QAction("Indent line", layoutMenu, checkable=True)
        indentLineAction.setChecked(showIndentLine)
        togglers.append(makeToggler("ShowIndentLine", not indentLineAction.isChecked()))
        indentLineAction.toggled.connect(togglers[-1])
        layoutMenu.addAction(indentLineAction)

        snapsLineAction = QtGui.QAction("Snaps line", layoutMenu, checkable=True)
        snapsLineAction.setChecked(showSnapsLine)
        togglers.append(makeToggler("ShowSnapsLine", not snapsLineAction.isChecked()))
        snapsLineAction.toggled.connect(togglers[-1])
        layoutMenu.addAction(snapsLineAction)

        consoleLineAction = QtGui.QAction("Console line", layoutMenu, checkable=True)
        consoleLineAction.setChecked(showConsoleLine)
        togglers.append(makeToggler("ShowConsoleLine", not consoleLineAction.isChecked()))
        consoleLineAction.toggled.connect(togglers[-1])
        layoutMenu.addAction(consoleLineAction)
#end settings->layout

        mainMenu.addMenu(settingsMenu)
#end of settings

#start goto menu
        gotoMenu = self.makeGotoMenu()
        mainMenu.addMenu(gotoMenu)
#start snaps menu
        snapsMenu = self.makeSnapsMenu()
        mainMenu.addMenu(snapsMenu)
#start templates menu
        templatesMenu = QtGui.QMenu("Templates")
        insertFromTemplateAction = QtGui.QAction("Insert from dialog")
        insertFromTemplateAction.triggered.connect(self.setupInsertFromTemplate)
        templatesMenu.addAction(insertFromTemplateAction)

        insertMenu = QtGui.QMenu("Insert")
        templatesMenu.addMenu(insertMenu)
        insertSubmenus = []

        templateDict = self.getTemplateString()
        def makeTemplateLambda(x): return lambda : self.testTemplateItem(key=x, execute=True)
        templateActions = []
        templateLambdas = [makeTemplateLambda(k) for k in sorted(templateDict.keys())]

        for ii, k in enumerate(sorted(templateDict.keys())):
            if ii % 25 == 0:
                insertSubmenus.append(QtGui.QMenu(f"Start from -- {k}"))
            templateActions.append(QtGui.QAction(k))
            templateActions[-1].triggered.connect(templateLambdas[ii])
            insertSubmenus[-1].addAction(templateActions[-1])
        for sub in insertSubmenus:
            insertMenu.addMenu(sub)

        editTemplateAction = QtGui.QAction("Edit templates")
        editTemplateAction.triggered.connect(self.editTemplates)
        templatesMenu.addAction(editTemplateAction)

        mainMenu.addMenu(templatesMenu)

#start help menu
        helpMenu = QtGui.QMenu("Help")
        mainMenu.addMenu(helpMenu)

#start help -> reference menu
        helpReferenceMenu = QtGui.QMenu("Reference")
        helpMenu.addMenu(helpReferenceMenu)

#start help -> reference -> 

        moduleMenu = QtGui.QMenu("FreeCAD Modules")
        helpReferenceMenu.addMenu(moduleMenu)
        def makeModule(x): return lambda : self.makeReferenceMenu(x)

        packagesDict = {
        "Draft":Draft,
        "DraftUtils":DraftUtils,
        "Fem": Fem,
        "FemGui": FemGui,
        "Image": Image,
        "ImageGui": ImageGui,
        "Measure": Measure,
        "Mesh": Mesh,
        "MeshGui": MeshGui,
        "MeshPart": MeshPart,
        "MeshPartGui":MeshPartGui,
        "PartDesign": PartDesign,
        "PartDesignGui":PartDesignGui,
        "Part":Part,
        "PartGui":PartGui,
        "Path":Path,
        "PathGui":PathGui,
        "PathSimulator":PathSimulator,
        "Points":Points,
        "PointsGui":PointsGui,
        "Sketcher":Sketcher,
        "SketcherGui":SketcherGui,
        "Spreadsheet":Spreadsheet,
        "SpreadsheetGui":SpreadsheetGui,
        "TechDraw":TechDraw,
        "TechDrawGui":TechDrawGui,
        "Web":Web,
        "WebGui":WebGui
        }
        moduleActions = []
        modules = []
        for k,v in packagesDict.items():
            moduleActions.append(QtGui.QAction(k))
            modules.append(makeModule(v))
            moduleActions[-1].triggered.connect(modules[-1])
            moduleMenu.addAction(moduleActions[-1])

        FreeCADAction = QtGui.QAction("FreeCAD/App")
        FreeCADAction.triggered.connect(lambda :self.makeReferenceMenu(FreeCAD))
        helpReferenceMenu.addAction(FreeCADAction)

        FreeCADGuiAction = QtGui.QAction("FreeCADGui/Gui")
        FreeCADGuiAction.triggered.connect(lambda :self.makeReferenceMenu(FreeCADGui))
        helpReferenceMenu.addAction(FreeCADGuiAction)


        qtMenu = QtGui.QMenu("Qt/PySide")
        helpReferenceMenu.addMenu(qtMenu)

        QtCoreAction = QtGui.QAction("QtCore")
        QtCoreAction.triggered.connect(lambda :self.makeReferenceMenu(QtCore))
        qtMenu.addAction(QtCoreAction)

        QtCore_QtAction = QtGui.QAction("QtCore.Qt")
        QtCore_QtAction.triggered.connect(lambda :self.makeReferenceMenu(QtCore.Qt))
        qtMenu.addAction(QtCore_QtAction)

        QtGuiAction = QtGui.QAction("QtGui")
        QtGuiAction.triggered.connect(lambda :self.makeReferenceMenu(QtGui))
        qtMenu.addAction(QtGuiAction)

        QtNetworkAction = QtGui.QAction("QtNetwork")
        QtNetworkAction.triggered.connect(lambda :self.makeReferenceMenu(QtNetwork))
        qtMenu.addAction(QtNetworkAction)

        QtHelpAction = QtGui.QAction("QtHelp")
        QtHelpAction.triggered.connect(lambda :self.makeReferenceMenu(QtHelp))
        qtMenu.addAction(QtHelpAction)

        QtMultimediaAction = QtGui.QAction("QtMultimedia")
        QtMultimediaAction.triggered.connect(lambda :self.makeReferenceMenu(QtMultimedia))
        qtMenu.addAction(QtMultimediaAction)

        QtOpenGLAction = QtGui.QAction("QtOpenGL")
        QtOpenGLAction.triggered.connect(lambda :self.makeReferenceMenu(QtOpenGL))
        qtMenu.addAction(QtOpenGLAction)

        QtPrintSupportAction = QtGui.QAction("QtPrintSupport")
        QtPrintSupportAction.triggered.connect(lambda :self.makeReferenceMenu(QtPrintSupport))
        qtMenu.addAction(QtPrintSupportAction)

        QtSqlAction = QtGui.QAction("QtSql")
        QtSqlAction.triggered.connect(lambda :self.makeReferenceMenu(QtSql))
        qtMenu.addAction(QtSqlAction)

        QtSvgAction = QtGui.QAction("QtSvg")
        QtSvgAction.triggered.connect(lambda :self.makeReferenceMenu(QtSvg))
        qtMenu.addAction(QtSvgAction)

        QtTestAction = QtGui.QAction("QtTest")
        QtTestAction.triggered.connect(lambda :self.makeReferenceMenu(QtTest))
        qtMenu.addAction(QtTestAction)

        QtWidgetsAction = QtGui.QAction("QtWidgets")
        QtWidgetsAction.triggered.connect(lambda :self.makeReferenceMenu(QtWidgets))
        qtMenu.addAction(QtWidgetsAction)

        QtXmlAction = QtGui.QAction("QtXml")
        QtXmlAction.triggered.connect(lambda :self.makeReferenceMenu(QtXml))
        qtMenu.addAction(QtXmlAction)

        QtXmlPatternsAction = QtGui.QAction("QtXmlPatterns")
        QtXmlPatternsAction.triggered.connect(lambda :self.makeReferenceMenu(QtXmlPatterns))
        qtMenu.addAction(QtXmlPatternsAction)

        searchMenu = QtGui.QMenu("Search source code")
        searchAction = QtGui.QAction("Use find edit text")
        searchAction.triggered.connect(self.makeSearchFromFindEdit)
        searchMenu.addAction(searchAction)

        searchSelAction = QtGui.QAction("Use selected text")
        searchSelAction.triggered.connect(self.makeSearchFromSelection)
        searchMenu.addAction(searchSelAction)

        searchAskAction = QtGui.QAction("Ask for query")
        searchAskAction.triggered.connect(self.makeSearchFromImmediate)
        searchMenu.addAction(searchAskAction)

        helpMenu.addMenu(searchMenu)

        qSearchMenu = QtGui.QMenu("Search Qt")
        qSearchAction = QtGui.QAction("Use find edit text")
        qSearchAction.triggered.connect(self.makeqSearchFromFindEdit)
        qSearchMenu.addAction(qSearchAction)

        qSearchSelAction = QtGui.QAction("Use selected text")
        qSearchSelAction.triggered.connect(self.makeqSearchFromSelection)
        qSearchMenu.addAction(qSearchSelAction)

        qSearchAskAction = QtGui.QAction("Ask for query")
        qSearchAskAction.triggered.connect(self.makeqSearchFromImmediate)
        qSearchMenu.addAction(qSearchAskAction)

        helpMenu.addMenu(qSearchMenu)
#highlight menu
        highlightMenu = QtGui.QMenu("Highlight", mw)
        highlightFromSelectionAction = QtGui.QAction("From selection")
        highlightFromSelectionAction.triggered.connect(self.highlightFromSelection)
        highlightMenu.addAction(highlightFromSelectionAction)

        highlightFromFindAction = QtGui.QAction("From find")
        highlightFromFindAction.triggered.connect(self.highlightFromFind)
        highlightMenu.addAction(highlightFromFindAction)

        #unHighlightAction = QtGui.QAction("Unhighlight")
        #unHighlightAction.triggered.connect(self.unHighlight)
        #highlightMenu.addAction(unHighlightAction)



        mainMenu.addMenu(highlightMenu)

#close menu
        if self.isTabbed:
            closeAction = QtGui.QAction("Close")
            closeAction.triggered.connect(self.close)
            mainMenu.addAction(closeAction)
        mainMenu.exec_(self.mainMenuBtn.mapToGlobal(QtCore.QPoint()))

    #credit Amartel at stackoverflow for this bit of code
    def getLineNumberAtCursor(self):
        cursor = self.currentEditor.textCursor()
        cursor.movePosition(QtGui.QTextCursor.StartOfLine)
        lines = 1
        lines_text = cursor.block().text().splitlines()
        lines_pos = 0
        for line_text in lines_text:
            lines_pos += len(line_text) + 1
            if lines_pos > cursor.position() - cursor.block().position():
                break
            lines += 1
        block = cursor.block().previous()
        while block.isValid():
            lines += block.lineCount()
            block = block.previous()
        return lines

    def setupInsertFromTemplate(self):
        templateDict = self.getTemplateString()
        items=[]
        for k,v in templateDict.items():
            items.append(k)
        if not items:
            self.toast("No keys in template","Error")
            return
        item,ok = QtGui.QInputDialog.getItem(mw, "Select template","Select which template to insert", sorted(items))
        if ok:
            self.testTemplateItem(key=item, execute=True)

    def testTemplateItem(self, key, testText="", execute=False):
        """test template from editor, but also can execute"""
        def inp(title="Input",label="Enter a value:"): return lambda:QtGui.QInputDialog.getMultiLineText(Gui.getMainWindow(), title, label)
        def inp1(title="Input",label="Enter a value:"): return lambda:QtGui.QInputDialog.getText(Gui.getMainWindow(), title, label)
        if not testText:
            templateDict = self.getTemplateString()
            rawDict = templateDict[key]
        else:
            rawDict = json.loads(testText, strict=False)
        if not "output" in rawDict:
            self.toast("Test failed: no key named 'output'","Error")
            return ""
        if rawDict["output"] == "input":
            retval,ok = inp(f"Input for {key}",f"Enter a value for {replacement[0]}")()
            rawOutString = retval if ok else None
        elif rawDict["output"] == 'input1':
            retval,ok = inp1Line(f"Input for {key}",f"Enter a value for {replacement[0]}")()
            rawOutString = retval if ok else None
        elif rawDict["output"] == "clipboard":
            rawOutString = QtGui.QClipboard().text()
        elif rawDict["output"] == "selection":
            rawOutString = self.currentEditor.textCursor().selectedText()
        else:
            rawOutString = rawDict["output"]
        if not rawOutString:
            self.toast("Empty output value","Error")
            return ""
        replacements = [(k,v) for k,v in rawDict.items() if k != "output" and k!= "goto"]
        for replacement in replacements:
            if replacement[1] == 'input':
                retval,ok = inp(f"Input for {key}",f"Enter a value for {replacement[0]}")()
                rawDict[replacement[0]] = retval if ok else None
            elif replacement[1] == 'input1':
                retval,ok = inp1Line(f"Input for {key}",f"Enter a value for {replacement[0]}")()
                rawDict[replacement[0]] = retval if ok else None
            elif replacement[1] == "selection":
                rawDict[replacement[0]] = self.currentEditor.textCursor().selectedText()
            elif replacement[1] == 'clipboard':
                clipTxt = QtGui.QClipboard().text()
                rawDict[replacement[0]] = clipTxt
                if not clipTxt:
                    self.toast("Clipboard is empty","Warning")
            elif replacement[1] == 'selection':
                selTxt = self.currentEditor.textCursor().selectedText()
                rawDict[replacement[0]] = selTxt
                if not selTxt:
                    self.toast("Selection is empty","Warning")
            elif replacement[1] == 'find':
                findTxt = self.findEdit.text()
                rawDict[replacement[0]] = findTxt
                if not findTxt:
                    self.toast("Find edit is empty","Warning")
            elif replacement[1] == 'replace':
                replaceTxt = self.replaceEdit.text()
                rawDict[replacement[0]] = replaceTxt
                if not replaceTxt:
                    self.toast("Replace edit is empty","Warning")
        for replacement in replacements:
            rawOutString = rawOutString.replace(replacement[0],rawDict[replacement[0]])
        if not execute:
            return rawOutString
        if self.currentEditor:
            old_cursor = self.getTC(self.currentEditor.textCursor())
            self.setModified(self.editorList.currentItem().text(), \
                self.currentEditor.toPlainText(), f"Insert template: {key}", old_cursor)
            if  "goto" in rawDict:
                if rawDict["goto"] == "home":
                    self.gotoLine(1)
                elif rawDict["goto"] == '' or rawDict["goto"] == "current":
                    pass
                elif rawDict["goto"] == "end":
                    self.gotoLine(-1, eol=True)
                elif rawDict["goto"] == "input" or rawDict["goto"] == "input1":
                    line,ok = inp1("Line number","Input line number for goto\nCancel for current cursor position: ")()
                    if ok and line != "":
                        self.gotoLine(self.parseLine(line))
                elif rawDict["goto"].startswith("relative:"):
                    relativeMove = rawDict["goto"][len("relative:"):]
                    relativeLine = self.parseLine(relativeMove)
                    curLine = self.getLineNumberAtCursor()
                    self.gotoLine(curLine + relativeLine)
                else:
                    lineNumber = self.parseLine(rawDict["goto"])
                    if lineNumber != 0:
                        self.gotoLine(lineNumber)
            self.currentEditor.insertPlainText(rawOutString)
        else:
            self.toast("No editor to insert template into","Error")

    def getTemplateString(self):
        """updates self.templateDictString from templates file, returns dict"""
        import os
        real_path = os.path.realpath(__file__)
        dir_path = os.path.dirname(real_path)
        template_file = real_path.replace(".FCMacro","_Templates.txt")
        bHasFile = os.path.exists(template_file)
        if not bHasFile:
            dictString = self.pg.GetString("TemplateDictString","{}")
            if dictString == "{}": #no parameter
                templateDict = {
"button":{"label":"input", "name":"input","output":"name = QtGui.QPushButton('label')"},
"import QtGui, QtCore":{"output":"from PySide import QtGui, QtCore"}
}
            else:
                templateDict = json.loads(dictString) #preserve existing templates from parameters
            self.pg.RemString("TemplateDictString")
            self.setTemplateString(templateDict) #make the file with default samples
        else: #file already exists
            with open(template_file, 'r') as infile:
                self.templateDictString = infile.read()
            #self.templateDictString = self.pg.GetString("TemplateDictString","{}")
            templateDict = json.loads(self.templateDictString, strict=False)
        return templateDict

    def setTemplateString(self, new_dict):
        """saves to text file in json format"""
        formatted = json.dumps(new_dict,indent=0,separators=(','+chr(10),':'+chr(10)))
        formatted = formatted.replace('\\n',chr(10))

        import os
        real_path = os.path.realpath(__file__)
        dir_path = os.path.dirname(real_path)
        template_file = real_path.replace(".FCMacro","_Templates.txt")
        with open(template_file, 'w') as outfile:
            outfile.write(formatted)
        #self.pg.SetString("TemplateDictString", dumped)

    def editTemplates(self):
        dlg = TemplateEditor(form=self)
        #dlg.exec_()
        dlg.show()

    def makeSearchFromFindEdit(self):
        findTxt = self.findEdit.text()
        if not findTxt:
            self.toast("Nothing in Find edit","Error")
            return
        self.search(findTxt)

    def makeSearchFromSelection(self):
        self.onRefreshBtnClicked(True)
        if not self.currentEditor:
            self.toast("No current editor","Error")
            return
        tc = self.currentEditor.textCursor()
        findTxt = tc.selectedText()
        if not findTxt:
            self.toast("Nothing in selection","Error")
            return
        self.search(findTxt)

    def makeSearchFromImmediate(self):
        findTxt, ok = QtGui.QInputDialog.getText(mw, "Search source","Enter search query:")
        if ok:
            self.search(findTxt)

    def makeqSearchFromFindEdit(self):
        findTxt = self.findEdit.text()
        if not findTxt:
            self.toast("Nothing in Find edit","Error")
            return
        self.qSearch(findTxt)

    def makeqSearchFromSelection(self):
        self.onRefreshBtnClicked(True)
        if not self.currentEditor:
            self.toast("No current editor","Error")
            return
        tc = self.currentEditor.textCursor()
        findTxt = tc.selectedText()
        if not findTxt:
            self.toast("Nothing in selection","Error")
            return
        self.qSearch(findTxt)

    def makeqSearchFromImmediate(self):
        findTxt, ok = QtGui.QInputDialog.getText(mw, "Search Qt","Enter qSearch query:")
        if ok:
            self.qSearch(findTxt)

    def makeReferenceMenu(self, mod):
        def makeReference(name): return lambda: self.showHelp(name)
        if isinstance(mod, str):
            mod = __import__(mod)
        refMenu = QtGui.QMenu(mod.__name__)
        subMenus = []

        attributeStrings = [att for att in dir(mod) if not "__" in att]

        attrActions = []
        attrActions.append(QtGui.QAction(f"{mod.__name__}"))
        attrActions[-1].triggered.connect(makeReference(f"{mod.__name__}"))
        refMenu.addAction(attrActions[-1])
        if not attributeStrings:
            self.showHelp(mod)
        ii = 0
        for attr in attributeStrings:
            if ii % 50 == 0:
                subMenus.append(QtGui.QMenu(f"Start from -- {mod.__name__}.{attr}"))
                ii += 1
            if not hasattr(mod, "__name__"):
                continue
            attrActions.append(QtGui.QAction(f"{mod.__name__}.{attr}"))
            attrActions[-1].triggered.connect(makeReference(f"{mod.__name__}.{attr}"))
            subMenus[-1].addAction(attrActions[-1])
            ii += 1

        for sub in subMenus:
            refMenu.addMenu(sub)
        if exec:
            refMenu.exec_(QtCore.QPoint())
        else:
            return refMenu

    def showHelp(self, name):
        if isinstance(name, str) and name[:3] == "Qt.":
            name = "PySide2.QtCore." + name
        from contextlib import redirect_stdout
        import io
        f = io.StringIO()
        with redirect_stdout(f):
            print(f"help({name}):")
            help(f"{name}")
        #self.print(f.getvalue())
        self.makeWindow(name, f.getvalue())

    def makeWindow(self, name, txt):
        """make a window to show some text"""
        dlg = QtGui.QDialog(mw)
        edit = QtGui.QPlainTextEdit()
        edit.setPlainText(txt)
        layout = QtGui.QVBoxLayout()
        layout.addWidget(edit)
        dlg.setLayout(layout)
        dlg.resize(800,600)
        dlg.setWindowTitle(f"help on {name}")
        dlg.setAttribute(QtCore.Qt.WA_DeleteOnClose, True)
        self.mdi.addSubWindow(dlg)
        dlg.show()

    def close(self):
        self.mdi.subWindowActivated.disconnect(self.onSubWindowActivated)
        self.form.close()

    def onSnapMenuBtnClicked(self, arg1):
        qp = QtCore.QPoint()
        self.snapMenuBtnContextMenu(qp)

    def makeSnapsMenu(self):
        snapsMenu = QtGui.QMenu("Snaps")
        self.onRefreshBtnClicked(True)
        curName = self.editorList.currentItem().text() if self.editorList.count() else ""
        if not curName:
            self.toast("No current editor","Error")
        snaps = [snap for snap in reversed(self.snaps) if snap["name"] == curName]

        takeSnapshotAction = QtGui.QAction("Take snapshot", mw)
        takeSnapshotAction.triggered.connect(lambda: self.onTakeSnapBtnClicked(True))
        snapsMenu.addAction(takeSnapshotAction)
        takeSnapshotAction.setEnabled(curName != "")

        restoreMenu = QtGui.QMenu("Restore last snap")
        restoreToCurrentEditorAction = QtGui.QAction("Restore to current editor", mw)
        restoreToCurrentEditorAction.triggered.connect(self.doRestoreToCurrentEditor)
        restoreToCurrentEditorAction.setEnabled(len(snaps) > 0)
        restoreMenu.addAction(restoreToCurrentEditorAction)

        restoreToClipboardAction = QtGui.QAction("Restore to clipboard", mw)
        restoreToClipboardAction.triggered.connect(self.doRestoreToClipboard)
        restoreToClipboardAction.setEnabled(len(snaps) > 0)
        restoreMenu.addAction(restoreToClipboardAction)

        restoreToTextDocumentAction = QtGui.QAction("Restore to new Text document", mw)
        restoreToTextDocumentAction.triggered.connect(self.doRestoreToTextDocument)
        restoreToTextDocumentAction.setEnabled(len(snaps) > 0)
        restoreMenu.addAction(restoreToTextDocumentAction)
        snapsMenu.addMenu(restoreMenu)
        if not len(self.getSnaps()):
            restoreMenu.setEnabled(False)

        def makeRestoreAnyLambda(name,reason,idx): return lambda: self.restoreAny(name,reason,idx)

        restoreAnys = self.getRestoreAnys()
        restoreAnysMenu = QtGui.QMenu("Restore Any")
        restoreAnyActions = []
        restoreAnyLambdas = [makeRestoreAnyLambda(tup[0],tup[1],ii) for ii,tup in enumerate(restoreAnys)]
        for ii,tup in enumerate(restoreAnys):
            restoreAnyActions.append(QtGui.QAction(f"Restore {tup[0]}: {tup[1]}", mw))
            restoreAnyActions[-1].triggered.connect(restoreAnyLambdas[ii])
            restoreAnysMenu.addAction(restoreAnyActions[-1])
        snapsMenu.addMenu(restoreAnysMenu)
        if not restoreAnys:
            restoreAnysMenu.setEnabled(False)

        saveMenu = QtGui.QMenu("Save")
        saveSnapshotAsAction = QtGui.QAction("Save snapshot as...", mw)
        saveSnapshotAsAction.triggered.connect(self.doSaveSnapshotAs)
        saveSnapshotAsAction.setEnabled(len(snaps) > 0)
        saveMenu.addAction(saveSnapshotAsAction)

        saveAllSnapshotAsAction = QtGui.QAction("Save all snaps to JSON file...", mw)
        saveAllSnapshotAsAction.triggered.connect(self.saveSnapsToJSON)
        saveAllSnapshotAsAction.setEnabled(len(snaps) > 0)
        saveMenu.addAction(saveAllSnapshotAsAction)
        snapsMenu.addMenu(saveMenu)
        if not len(self.getSnaps()):
            saveMenu.setEnabled(False)

        loadMenu = QtGui.QMenu("Load")
        loadSnapshotAction = QtGui.QAction("Load snapshots from JSON...", mw)
        loadSnapshotAction.triggered.connect(self.loadSnapsFromJSON)
        loadMenu.addAction(loadSnapshotAction)

        snapsMenu.addMenu(loadMenu)
        discardMenu = QtGui.QMenu("Discard")

        def makeDiscardSnapLambda(x): return lambda: self.discardSnap(x)

        discardAction = QtGui.QAction("Discard latest snap", mw)
        discardAction.setToolTip("Discards most recent snap for the current editor")
        discardAction.triggered.connect(self.discardSnap)
        discardAction.setEnabled(len(snaps) > 0)
        discardMenu.addAction(discardAction)

        discardAllAction = QtGui.QAction("Discard all snaps", mw)
        discardAllAction.setToolTip("Disards all snaps for all editors")
        discardAllAction.triggered.connect(self.discardAllSnaps)
        discardAllAction.setEnabled(len(snaps) > 0)
        discardMenu.addAction(discardAllAction)

        discardSnaps = self.getSnaps()
        discardSnapActions = []
        discardSnapLambdas = [makeDiscardSnapLambda(ii) for ii,snap in enumerate(discardSnaps)]
        for ii,snap in enumerate(discardSnaps):
            discardSnapActions.append(QtGui.QAction(f"Discard {snap['reason']}", mw))
            discardSnapActions[-1].triggered.connect(discardSnapLambdas[ii])
            discardMenu.addAction(discardSnapActions[-1])
        if not discardSnaps:
            discardMenu.setEnabled(False)

        snapsMenu.addMenu(discardMenu)

        def makeDiffLambda(x,y,xlab="",ylab=""): return lambda: self.showDiff(x,y,xlab,ylab)

        diffSnaps = self.getDiffSnaps(curName)
        diffSnapsMenu = QtGui.QMenu("Diff current editor")
        diffSnapActions = []
        diffSnapLambdas = [makeDiffLambda(snap['name'],ii) for ii,snap in enumerate(diffSnaps)]
        for ii,snap in enumerate(diffSnaps):
            diffSnapActions.append(QtGui.QAction(f"Diff {snap['reason']}", mw))
            diffSnapActions[-1].triggered.connect(diffSnapLambdas[ii])
            diffSnapsMenu.addAction(diffSnapActions[-1])

        for edName in self.editorDict.keys():
            if edName == curName:
                continue
            diffSnapActions.append(QtGui.QAction(f"Diff {edName}", mw))
            diffSnapLambdas.append(makeDiffLambda(self.getText(edName), self.getText(curName), curName, edName))
            diffSnapActions[-1].triggered.connect(diffSnapLambdas[-1])
            diffSnapsMenu.addAction(diffSnapActions[-1])

        clipText = QtGui.QClipboard().text()

        diffSnapActions.append(QtGui.QAction(f"Diff clipboard text", mw))
        diffSnapLambdas.append(makeDiffLambda(clipText, self.getText(curName),curName, "Clipboard text"))
        diffSnapActions[-1].triggered.connect(diffSnapLambdas[-1])
        diffSnapsMenu.addAction(diffSnapActions[-1])
        if not clipText:
            diffSnapActions[-1].setEnabled(False)

        snapsMenu.addMenu(diffSnapsMenu)
        if not diffSnapActions:
            diffSnapsMenu.setEnabled(False)

        def makeEditReasonLambda(name,reason,idx): return lambda: self.editReason(name,reason,idx)

        editReasons = self.getEditReasons(curName)
        editReasonsMenu = QtGui.QMenu("Edit reason")
        editReasonActions = []
        editReasonLambdas = [makeEditReasonLambda(tup[0],tup[1],ii) for ii,tup in enumerate(editReasons)]
        for ii,tup in enumerate(editReasons):
            editReasonActions.append(QtGui.QAction(f"Edit reason {tup[0]}: {tup[1]}", mw))
            editReasonActions[-1].triggered.connect(editReasonLambdas[ii])
            editReasonsMenu.addAction(editReasonActions[-1])
        snapsMenu.addMenu(editReasonsMenu)
        if not editReasons:
            editReasonsMenu.setEnabled(False)
        return snapsMenu


    def snapMenuBtnContextMenu(self, point):
        snapsMenu = self.makeSnapsMenu()

        snapsMenu.exec_(self.snapMenuBtn.mapToGlobal(point))

    def editReason(self, name, reason, idx):
        snap = self.snaps[idx]
        new_reason,ok = QtGui.QInputDialog.getText(mw,"Edit reason",f"Enter a new reason in place of:\n\
{reason}\n", text=reason)
        if not ok:
            return
        snap['reason'] = new_reason
        self.snaps[idx] = snap
        self.toast(f"snap of {name}:{reason} updated to {new_reason}","Information")
        return

    def getEditReasons(self,curName):
        """list of tuple(name, reason, idx)"""
        editReasons = [tuple([snap['name'],snap['reason'],ii]) for ii,snap in enumerate(self.snaps)]
        return editReasons

    def doRestoreToCurrentEditor(self):
        snaps = self.getSnaps()
        if not snaps:
            self.toast("No snaps to restore", "Error")
            return
        self.restoreAny(snaps[0]['name'], snaps[0]['reason'],0)

    def restoreAny(self, name, reason, idx):
        """restore any snap to current document"""
        snap = self.snaps[idx]
        curName = self.editorList.currentItem().text() if self.editorList.currentItem() else ""
        if not curName:
            self.toast("Invalid current editor","Error")
            return
        if curName != name:
            items = ["Oops, wrong document -- cancel",f"I confirm: overwrite {curName} with this snap"]
            item,ok = QtGui.QInputDialog.getItem(mw,f"Restore",f"You are about to restore:{name}: {reason} to a different document: {curName}.\n",items)
            if not bool (ok and item == items[1]):
                return
        old_text = self.getText(curName)
        old_cursor = self.currentEditor.textCursor()
        self.currentEditor.setPlainText(snap["old_text"])
        self.setTextCursor(self.editorList.currentItem().text(), snap['tc'])
        self.setModified(curName, old_text, f"Restore {snap['reason']}", self.getTC(old_cursor))
        self.toast(f"snap of {name}:{reason} updated to {curName}: {snap['reason']}","Information")
        return

    def getRestoreAnys(self):
        """list of tuple(name, reason, idx)"""
        restoreAnys = [tuple([snap['name'],snap['reason'],ii]) for ii,snap in enumerate(self.snaps)]
        return restoreAnys

    def saveSnapsToJSON(self):
        """save all snaps to a JSON text file"""
        fname = QtGui.QFileDialog.getSaveFileName(FreeCADGui.getMainWindow(),"Save all snaps to a JSON file",filter='*.*')[0]
        if not fname:
            return
        with open(fname, "w") as outfile:
            json.dump(self.snaps, outfile)
        self.toast(f"All snaps saved to {outfile}", "Information")

    def loadSnapsFromJSON(self):
        """load previously saved snaps from a JSON file"""
        fname = QtGui.QFileDialog.getOpenFileName(FreeCADGui.getMainWindow(),"Open a JSON file",filter='*.*')[0]
        if not fname:
            return
        try:
            f = open(fname)
        except Exception as ex:
            self.toast(f"{ex}","Error")
            return
        try:
            self.snaps = json.load(f)
        except Exception as ex:
            self.toast(f"{ex}","Error")
            f.close()
            return
        self.updateSnapBtns()
        self.toast(f"Snaps loaded and restored from {fname}","Message")


    def getDiffSnaps(self, name):
        self.onRefreshBtnClicked(True)
        curName = name
        snaps = [snap for snap in reversed(self.snaps) if snap["name"] == curName]
        return snaps

    def showDiff(self, name, idx, firstLabel = "", secondLabel = ""):
        """make a diff of the snap and the text in the current editor"""
        if isinstance(idx, int):
            snaps = self.getDiffSnaps(name)
            plainText = self.getText(name).splitlines()
            plainLabel = name
            snapText = snaps[idx]['old_text'].splitlines()
            snapLabel = snaps[idx]['reason']
        else: #presume to be strings passed in to be diffed
            snapText = name.splitlines()
            plainText = idx.splitlines()
            plainLabel = firstLabel
            snapLabel = secondLabel
        d = difflib.HtmlDiff(tabsize=4)
        ds = DiffSaver(form=self, snapText=snapText, plainText=plainText, label2=plainLabel, label1=snapLabel)
        ds.setWindowFlag(QtCore.Qt.WindowMinimizeButtonHint, True)
        ds.setWindowFlag(QtCore.Qt.WindowMaximizeButtonHint, True)
        ds.resizeEvent = ds.onResize
        self.mdi.addSubWindow(ds)
        layout = QtGui.QVBoxLayout()
        ds.setLayout(layout)
        ds.setWindowIcon(QIconFromXPMString(__icon__))
        from PySide2 import QtWebEngineWidgets as Web
        ds.webView = Web.QWebEngineView()
        #ds.webView.setHtml(ds.diff)
        saveBtn = QtGui.QPushButton("Save to html...")
        saveBtn.clicked.connect(ds.saveDiffToHtml)
        sliderLayout=QtGui.QHBoxLayout()
        sliderLayout.addWidget(saveBtn)
        ds.numlinesSpinBox = QtGui.QSpinBox()
        ds.numlinesSpinBox.setValue(5)
        ds.contextCheckBox = QtGui.QCheckBox()
        ds.contextCheckBox.setCheckState(QtCore.Qt.Checked)
        sliderLayout.addWidget(QtGui.QLabel("Context:"))
        sliderLayout.addWidget(ds.contextCheckBox)
        sliderLayout.addWidget(QtGui.QLabel("Context lines:"))
        sliderLayout.addWidget(ds.numlinesSpinBox)
        ds.contextCheckBox.stateChanged.connect(ds.onContextCheckBoxStateChanged)
        ds.numlinesSpinBox.valueChanged.connect(ds.onNumlinesSpinBoxValueChanged)
        sliderLayout.addWidget(QtGui.QLabel("Zoom:"))
        ds.slider = QtGui.QSlider(QtCore.Qt.Horizontal)
        ds.slider.setRange(25, 500)
        ds.slider.valueChanged.connect(ds.onSliderValueChanged)
        ds.slider.setMinimum(25)
        ds.slider.setMaximum(500)
        ds.slider.setTickPosition(QtGui.QSlider.TicksBelow)
        ds.slider.setTickInterval(25)
        ds.slider.setValue(100)
        sliderLayout.addWidget(ds.slider)
        sliderLayout.addWidget(QtGui.QLabel("Col width:"))
        ds.widthSlider = QtGui.QSlider(QtCore.Qt.Horizontal)
        ds.widthSlider.setRange(25, 2000)
        ds.widthSlider.valueChanged.connect(ds.onWidthSliderValueChanged)
        ds.widthSlider.setMinimum(25)
        ds.widthSlider.setMaximum(2000)
        ds.widthSlider.setTickPosition(QtGui.QSlider.TicksBelow)
        ds.widthSlider.setTickInterval(25)
        ds.widthSlider.setValue(500)
        sliderLayout.addWidget(ds.widthSlider)
        layout.addLayout(sliderLayout)
        layout.addWidget(ds.webView)

        ds.show()
        ds.resize(640,480)
        self.onRefreshBtnClicked(True)
        #self.toast(f"make diff of snap = {idx}","Message")


    def doSaveSnapshotAs(self):
        self.onRefreshBtnClicked(True)
        curName = self.editorList.currentItem().text()
        snaps = [snap for snap in reversed(self.snaps) if snap["name"] == curName]
        if not snaps:
            self.toast("No saved snapshot to save as","Error")
            self.updateSnapBtns()
            return
        else:
            fname = QtGui.QFileDialog.getSaveFileName(FreeCADGui.getMainWindow(),\
                "Save snapshot to text file",filter='Macro (*.FCmacro *.py);;Text file (*.txt);;Any (*.*)')[0]
            if not fname:
                return
            with open(fname,"w") as outfile:
                outfile.write(snaps[0]['old_text'])
            self.toast(f"Snapshot: {snaps[0]['reason']} saved to {fname}","Message")

    def doRestoreToClipboard(self):
        self.onRefreshBtnClicked(True)
        curName = self.editorList.currentItem().text()
        snaps = [snap for snap in reversed(self.snaps) if snap["name"] == curName]
        if not snaps:
            self.toast("No saved snapshot to send to clipboard","Error")
            self.updateSnapBtns()
            return
        else:
            clipboard = QtGui.QClipboard()
            clipboard.setText(snaps[0]["old_text"])
            self.toast(f"Snapshot: {snaps[0]['reason']} sent to clipboard","Message")

    def doRestoreToTextDocument(self):
        self.onRefreshBtnClicked(True)
        curName = self.editorList.currentItem().text()
        snaps = [snap for snap in reversed(self.snaps) if snap["name"] == curName]
        if not snaps:
            self.toast("No saved snapshot to restore to text document","Error")
            self.updateSnapBtns()
            return
        else:
            doc = FreeCAD.ActiveDocument if FreeCAD.ActiveDocument else FreeCAD.newDocument()
            textDoc = doc.addObject("App::TextDocument","Text document")
            textDoc.Text = snaps[0]['old_text']
            self.toast(f"Snapshot: {snaps[0]['reason']} sent to {textDoc.Name}","Message")
            textDoc.ViewObject.doubleClicked()
            doc.recompute()

    def onUndoBtnClicked(self, arg1):
        self.onRefreshBtnClicked(True)
        self.updateUndoBtn()
        curName = self.editorList.currentItem().text()
        curCursor = self.editorDict[curName].textCursor()
        for queue in reversed(self.undoQueue):
            if curName == queue["name"]:
                redo = {"name":curName, "reason":queue["reason"], "old_text":self.getText(curName), "tc":self.getTC(curCursor)}
                self.currentEditor.setPlainText(queue["old_text"])
                self.setTextCursor(curName, queue['tc'])
                self.redoQueue.append(redo)
                self.undoQueue.pop()
                self.updateUndoBtn()
                break

    def onUndoClearBtnClicked(self, arg1):
        count = len(self.undoQueue) + len(self.redoQueue)
        self.undoQueue = []
        self.redoQueue = []
        self.updateUndoBtn()
        self.toast(f"Undo/redo queues purged ({count} items)","Message")

    def onRedoBtnClicked(self, arg1):
        self.onRefreshBtnClicked(True)
        self.updateUndoBtn()
        curName = self.editorList.currentItem().text()
        for queue in reversed(self.redoQueue):
            if curName == queue["name"]:
                undo = {"name":curName, "reason":queue["reason"], "old_text":self.getText(curName), "tc":self.getTC(self.currentEditor.textCursor())}
                self.currentEditor.setPlainText(queue["old_text"])
                #self.currentEditor.setTextCursor(queue['tc'])
                self.setTextCursor(curName, queue['tc'])
                self.undoQueue.append(undo)
                self.redoQueue.pop()
                self.updateUndoBtn()
                break

    def updateUndoBtn(self):
        self.undoBtn.setText("")
        if not self.editorList.currentItem():
            return
        curName = self.editorList.currentItem().text()

        self.undoBtn.setEnabled(False)
        for queue in reversed(self.undoQueue):
            if curName == queue["name"]:
                self.undoBtn.setText(f"Undo {queue['reason']}")
                self.undoBtn.setEnabled(True)
                break
        self.redoBtn.setText("")
        self.redoBtn.setEnabled(False)
        for queue in reversed(self.redoQueue):
            if curName == queue["name"]:
                self.redoBtn.setText(f"Redo {queue['reason']}")
                self.redoBtn.setEnabled(True)
                break
        self.undoClearBtn.setEnabled(len(self.undoQueue)+len(self.redoQueue))

    def onFindBackBtnClicked(self, arg1):
        self.onRefreshBtnClicked(True)
        if not shiboken.isValid(self.currentEditor) or not self.currentEditor:
            self.toast("current editor is invalid","Error")
            return
        self.currentEditor.setFocus()
        name = self.editorList.currentItem().text()
        txt = self.findEdit.text()
        modifiers = QtGui.QApplication.keyboardModifiers()
        if modifiers & QtCore.Qt.AltModifier:
            selText = self.currentEditor.textCursor().selectedText()
            self.findEdit.setText(selText if selText else txt)
            txt = self.findEdit.text()
        if modifiers & QtCore.Qt.ControlModifier:
            self.gotoLine(-1, silent=True, eol=True)

        self.found = False
        self.find(name, txt, True)
        if not self.found:
            if self.loopCheckBox.checkState():
                self.toast(f"{txt} not found in {name} --Looping back to end","Warning")
                self.gotoLine(-1, silent=True, eol=True)
            else:
                self.toast(f"{txt} not found backwards in {name}","Message")
        self.on_CBox_Find(txt)

    def setModified(self, name, old_text, reason, tc):
        self.undoQueue.append({"name":name, "old_text": old_text, "reason":reason, "tc":tc})
        if len(self.undoQueue) > UNDO_QUEUE_MAX_SIZE:
            self.toast(f"undo queue reached max size {UNDO_QUEUE_MAX_SIZE}\ndiscarding {self.undoQueue[0]['reason']}","Warning")
            self.undoQueue.pop(0)
        self.updateUndoBtn()
        self.currentEditor.document().setModified(True)
        self.currentEditor.centerCursor()

    def onIndentBtnClicked(self, arg1):
        self.onRefreshBtnClicked(True)
        if not shiboken.isValid(self.currentEditor) or not self.currentEditor:
            self.toast("current editor is invalid", "Error")
            return
        self.currentEditor.setFocus()
        old_text = self.getText()
        tc = self.currentEditor.textCursor()
        txt = tc.selectedText()
        if not txt:
            self.toast("nothing selected to indent")
            return
        lines = txt.splitlines()
        lines2 = ['    '+line for line in lines]
        joined = '\u2029'.join(lines2)
        tc.insertText(joined)
        self.setModified(self.editorList.currentItem().text(), old_text, "Indent >>", self.getTC(tc))
        tc.movePosition(QtGui.QTextCursor.Up, QtGui.QTextCursor.KeepAnchor, len(lines2)-1)
        tc.movePosition(QtGui.QTextCursor.StartOfLine, QtGui.QTextCursor.KeepAnchor)
        self.currentEditor.setTextCursor(tc)

    def onIndentBackBtnClicked(self, arg1):
        self.onRefreshBtnClicked(True)
        if not shiboken.isValid(self.currentEditor) or not self.currentEditor:
            self.toast("current editor is invalid", "Error")
            return
        self.currentEditor.setFocus()
        old_text = self.getText()
        old_cursor = self.currentEditor.textCursor()
        name = self.editorList.currentItem().text()
        tc = self.currentEditor.textCursor()
        txt = tc.selectedText()
        if not txt:
            self.toast("nothing selected to unindent")
            return
        lines = txt.splitlines()
        hasLeading = True
        for line in lines:
            if not line[:4] == '    ':
                hasLeading = False
        if not hasLeading:
            self.toast("Editor assistant: Cannot unindent selected block","Error")
            return
        lines2 = [line[4:] for line in lines]
        joined = '\u2029'.join(lines2)
        tc.insertText(joined)
        self.setModified(self.editorList.currentItem().text(), old_text, "<< Unindent", self.getTC(old_cursor))
        tc.movePosition(QtGui.QTextCursor.Up, QtGui.QTextCursor.KeepAnchor, len(lines2)-1)
        tc.movePosition(QtGui.QTextCursor.StartOfLine, QtGui.QTextCursor.KeepAnchor)
        self.currentEditor.setTextCursor(tc)

    def onReplaceAllBtnClicked(self, arg1):
        self.onRefreshBtnClicked(True)
        if not shiboken.isValid(self.currentEditor) or not self.currentEditor:
            self.toast("current editor is invalid", "Error")
            return
        self.currentEditor.setFocus()
        name = self.editorList.currentItem().text()
        txt = self.findEdit.text()
        newTxt = self.replaceEdit.text()
####new
        self.on_CBox_replaceEdit(newTxt)
####new
        self.replace(name, txt, newTxt)

    def onReplaceBtnClicked(self, arg1):
        self.onRefreshBtnClicked(True)
        if not shiboken.isValid(self.currentEditor) or not self.currentEditor:
            self.toast("current editor is invalid", "Error")
            return
        self.currentEditor.setFocus()
        document = self.currentEditor.document()
        name = self.editorList.currentItem().text()
        text_cursor = self.currentEditor.textCursor()
        txt = self.getText(name)
        start = text_cursor.selectionStart()
        end = text_cursor.selectionEnd()
        if start == end:
            self.toast("Nothing selected, press Find and try again")
            return
        txt1 = txt[:start]
        txt2 = txt[end:]
        newtxt = self.replaceEdit.text()
####new
        self.on_CBox_replaceEdit(newtxt)
####new
        newText = txt1 + newtxt + txt2
        self.setText(name,newText,f"replace {txt[start:end]}")
        text_cursor.setPosition(end)
        self.currentEditor.setTextCursor(text_cursor)
        self.onFindBtnClicked(True)

####new
    def on_CBox_replaceEdit(self,text):
        global duplicate_Replace

        if text not in duplicate_Replace:
            duplicate_Replace.append(text)
            duplicate_Replace = sorted(list(set(duplicate_Replace))) # sort
            self.CBox_replaceEdit.addItem(text)
        self.CBox_replaceEdit.setCurrentText(text)
        self.replaceEdit.setText(text)
####new

    def onRefreshBtnClicked(self, arg1):
        self.getEditors()
        self.toast(f"Refreshed","Information",1000,priority="low",log=False)
        self.editorDict = {}
        for zz in zip(self.editors, self.parents, self.grandparents):
            self.editorDict [zz[2].windowTitle()] = zz[0]
            #self.print(f"ed = {ed}")
        self.populateList()
        self.setCurrentEditor()

    def onGotoHomeBtnClicked(self, arg1):
        self.gotoLine(1)

    def onGotoEndBtnClicked(self, arg1):
        self.gotoLine(-1, eol=True)

    def gotoLineActionTriggered(self):
        line = self.getFirstLine()
        self.gotoLine(line)

    def parseLine(self, line_as_string):
        try:
            parsed = int(line_as_string)
            return parsed
        except ValueError as ve:
            self.print(f"{ve}","Error")
            return 0

    def getFirstLine(self):
        """gets first line in the Goto line edit"""
        if not self.gotoLineEdit.text():
            return 0
        else:
            lines = self.gotoLineEdit.text().split(',')
            if lines:
                return self.parseLine(lines[0])
            else:
                self.toast("Unable to parse lines","Error")
                return 0

    def getGotoLines(self):
        if not self.gotoLineEdit.text():
            return []
        lines = self.gotoLineEdit.text().split(',')
        parsed = [self.parseLine(line) for line in lines if self.parseLine(line)]
        return parsed

    def onGotoLineEditTextChanged(self, arg1):
        """save the goto line edit text for each editor"""
        name = self.editorList.currentItem().text() if self.editorList.currentItem() else ""
        if not name:
            return
        self.gotoLineDict[name] = arg1

    def makeGotoMenu(self):
        gotoMenu = QtGui.QMenu("Goto")
        self.onRefreshBtnClicked(True)
        curName = self.editorList.currentItem().text() if self.editorList.count() else ""
        if not curName:
            self.toast("No current editor","Error")

        lineNumsMenu = QtGui.QMenu("Line numbers")
        lineNums = self.getGotoLines()
        def makeLambda(x): return lambda: self.gotoLine(x)
        gotoLineLambdas = [makeLambda(lineNum) for lineNum in lineNums]
        gotoLineActions = []
        for ii,lineNum in enumerate(lineNums):
            gotoLineActions.append(QtGui.QAction(f"Go to line {lineNum}", mw))
            gotoLineActions[-1].triggered.connect(gotoLineLambdas[ii])
            gotoLineActions[-1].setEnabled(len(self.gotoLineEdit.text()) > 0)
            #gotoMenu.addAction(gotoLineActions[-1])
            lineNumsMenu.addAction(gotoLineActions[-1])
        gotoMenu.addMenu(lineNumsMenu)
        if not gotoLineLambdas:
            lineNumsMenu.setEnabled(False)

        #classDefLines = (class name, def/class text, line number)
        classDefLinesMenu = QtGui.QMenu("Class/Def lines")
        classDefLines = sorted(self.getClassDefLines())
        classDefLineActions = []
        classDefSubmenus = []
        classDefLineLambdas = [makeLambda(cl[2]) for cl in classDefLines]
        for ii,classDefLine in enumerate(classDefLines):
            if ii % 25 == 0:
                classDefSubmenus.append(QtGui.QMenu(f"Start from -- {classDefLine[2]}"))
            if "class" in classDefLine[1]:
                classDefLineActions.append(QtGui.QAction(f"{classDefLine[2]}..{classDefLine[1]}", mw))
            else: #def line
                classDefLineActions.append(QtGui.QAction(f"{classDefLine[2]}..({classDefLine[0]}) {classDefLine[1]}", mw))
            classDefLineActions[-1].triggered.connect(classDefLineLambdas[ii])
            classDefSubmenus[-1].addAction(classDefLineActions[-1])
        for sub in classDefSubmenus:
            classDefLinesMenu.addMenu(sub)
        gotoMenu.addMenu(classDefLinesMenu)
        if not classDefLineLambdas:
            classDefLinesMenu.setEnabled(False)

        bookmarks = sorted(self.getBookmarks())
        bookmarksMenu = QtGui.QMenu("Bookmarks")
        bookmarkActions = []
        bookmarkLambdas = [makeLambda(bm[1]) for bm in bookmarks]
        for ii,bm in enumerate(bookmarks):
            bookmarkActions.append(QtGui.QAction(f"{bm[0]} ({bm[1]})", mw))
            bookmarkActions[-1].triggered.connect(bookmarkLambdas[ii])
            bookmarksMenu.addAction(bookmarkActions[-1])
        gotoMenu.addMenu(bookmarksMenu)
        if not bookmarks:
            bookmarksMenu.setEnabled(False)

        findResults = sorted(self.getFindResults())
        findResultsMenu = QtGui.QMenu("Find results")
        findResultsSubmenus = []
        findResultActions = []
        findResultLambdas = [makeLambda(fr[0]) for fr in findResults]
        for ii,fr in enumerate(findResults):
            if ii % 25 == 0:
                findResultsSubmenus.append(QtGui.QMenu(f"Start from -- {fr[0]}"))
            findResultActions.append(QtGui.QAction(f"{fr[0]}..{fr[1]}{fr[2]}{fr[3]}..", mw))
            findResultActions[-1].triggered.connect(findResultLambdas[ii])
            findResultsSubmenus[-1].addAction(findResultActions[-1])
        for sub in findResultsSubmenus:
            findResultsMenu.addMenu(sub)
        gotoMenu.addMenu(findResultsMenu)
        if not findResults:
            findResultsMenu.setEnabled(False)
        else:
            if self.matchWholeCheckBox.checkState():
                self.toast("Whole words checkbox ignored in Find results menu","Warning")

        findSelResults = sorted(self.getFindResults(useSelection=True))
        findSelResultsMenu = QtGui.QMenu("Find selection results")
        findSelResultsSubmenus = []
        findSelResultActions = []
        findSelResultLambdas = [makeLambda(fsr[0]) for fsr in findSelResults]
        for ii,fsr in enumerate(findSelResults):
            if ii % 25 == 0:
                findSelResultsSubmenus.append(QtGui.QMenu(f"Start from --{fsr[0]}"))
            findSelResultActions.append(QtGui.QAction(f"{fsr[0]}..{fsr[1]}{fsr[2]}{fsr[3]}..", mw))
            findSelResultActions[-1].triggered.connect(findSelResultLambdas[ii])
            findSelResultsSubmenus[-1].addAction(findSelResultActions[-1])
        for sub in findSelResultsSubmenus:
            findSelResultsMenu.addMenu(sub)
        gotoMenu.addMenu(findSelResultsMenu)
        if not findSelResults:
            findSelResultsMenu.setEnabled(False)
        else:
            if self.matchWholeCheckBox.checkState():
                self.toast("Whole words checkbox ignored in Find selection results menu","Warning")

        gotoHomeAction = QtGui.QAction("Home", mw)
        gotoHomeAction.triggered.connect(lambda: self.onGotoHomeBtnClicked(True))
        gotoHomeAction.setEnabled(curName != "")
        gotoMenu.addAction(gotoHomeAction)

        gotoEndAction = QtGui.QAction("End", mw)
        gotoEndAction.triggered.connect(lambda: self.onGotoEndBtnClicked(True))
        gotoEndAction.setEnabled(curName != "")
        gotoMenu.addAction(gotoEndAction)


        return gotoMenu


    def onGotoMenuBtnClicked(self, arg1):

        gotoMenu = self.makeGotoMenu()
        gotoMenu.exec_(self.gotoMenuBtn.mapToGlobal(QtCore.QPoint()))


    def onGotoLineEditReturnPressed(self):
        lines = self.getGotoLines()
        if len(lines) == 1:
            self.gotoLine(lines[0])
        else:
            self.onGotoMenuBtnClicked(True)

    def gotoLine(self,line,silent=False,eol=False):
        self.onRefreshBtnClicked(True)
        if not shiboken.isValid(self.currentEditor):
            self.toast("No valid current editor","Error")
            return
        document = self.currentEditor.document()
        if line < 0:
            txt = self.getText()
            txt_lines = txt.splitlines()
            txt_len = len(txt_lines)
            line = txt_len + 1 + line
        text_block = document.findBlockByLineNumber(line-1)
        if not text_block.isValid():
            self.toast(f"Cannot goto Line# {line} of {self.editorList.currentItem().text()}")
            return
        text_cursor = self.currentEditor.textCursor()
        text_cursor.setPosition(text_block.position())
        if eol:
            text_cursor.movePosition(QtGui.QTextCursor.EndOfLine)
        self.currentEditor.setTextCursor(text_cursor)
        self.currentEditor.centerCursor()
        if not silent:
            self.toast(f"Goto Line #{line} of {self.editorList.currentItem().text()}","Message")

    def getLines(self,name=None):
        """get plain text as string list"""
        txt = self.getText(name)
        return txt.splitlines()

    def getTrimmedLines(self, name=None):
        """remove all leading whitespace"""
        lines = self.getLines(name)
        lines2 = []
        for line in lines:
            lines2.append(line.strip())
        return lines2

    def getFindResults(self, useSelection=False):
        lines = self.getTrimmedLines()
        findResults = []
        if not shiboken.isValid(self.currentEditor):
            return []
        selTxt = self.currentEditor.textCursor().selectedText() if self.currentEditor else ""
        find = self.findEdit.text() if not useSelection else selTxt
        description_range = 35
        preContext = 10
        if not find:
            return []
        matchCase = self.matchCaseCheckBox.checkState()
        if not matchCase:
            find = find.lower()
        for ii,line in enumerate(lines):
            if find in line or bool(not matchCase and find in line.lower()):
                idx = line.find(find) if matchCase else line.lower().find(find)
                preDesc = line[:idx]# what comes before the find text
                desc = line[idx:]
                if len(preDesc) > preContext:
                    preDesc = preDesc[-preContext:]
                if len(desc) > description_range:
                    desc = desc[:description_range]
                    desc = line[idx:idx+description_range]
                findResults.append(tuple([ii+1, preDesc, find, desc[len(find):]]))
        return findResults

    def getBookmarks(self):
        lines = self.getTrimmedLines()
        bookmarks = []
        for ii,line in enumerate(lines):
            if BOOKMARK_MARKER in line:
                descIdx = line.find(BOOKMARK_MARKER) + len(BOOKMARK_MARKER)
                desc = line[descIdx:].strip()
                if desc:
                    bookmarks.append(tuple([desc, ii+1]))
        return bookmarks

    def getClassDefLines(self):
        """tuple(class name, class/def line, line number)"""
        lines = self.getTrimmedLines()
        classDefLines = []
        curClass = ""
        prevClass = ""
        for ii,line in enumerate(lines):
            if "class " in line and ":" in line:
                prevClass = curClass
                idx = line.find("class ")
                pretext = line[:idx].replace(' ','').replace('#','')
                idx2 = line.find(":", idx)
                curClass = line[idx + len("class "):idx2] if not pretext else prevClass
                if "(" in curClass and ")" in curClass:
                    idx3 = curClass.find("(")
                    idx4 = curClass.find(")",idx3)
                    if idx4 > idx3:
                        curClass = curClass[:idx3]
                    else:
                        curClass = ""
                classDefLines.append(tuple([curClass, line[idx:idx2], ii+1]))
            elif "def " in line and ":" in line:
                idx = line.find("def ")
                idx2 = line.find(":", idx)
                classDefLines.append(tuple([curClass, line[idx:idx2], ii+1]))
        return classDefLines

    def populateList(self):
        self.blockSignals = True
        current = None
        if not shiboken.isValid(self.editorList):
            return
        if self.editorList.count() != 0:
            current = self.editorList.currentItem().text() if self.editorList.currentItem() else ""
        self.editorList.clear()
        for k in sorted(self.editorDict.keys()):
            self.editorList.addItem(k)

        if current and current in self.editorDict:
            items = self.editorList.findItems(current, QtCore.Qt.MatchExactly)
            self.editorList.setCurrentItem(items[0] if items else self.editorList.item(0))
            pass
        else:
            self.editorList.setCurrentRow(0)

        self.setCurrentEditor()
        self.blockSignals = False

    def print(self,message,type="Message"):
        if type == "Message" or type == "Information":
            FreeCAD.Console.PrintMessage(message+"\n")
        elif type == "Error":
            FreeCAD.Console.PrintError(message+"\n")
        elif type == "Warning":
            FreeCAD.Console.PrintWarning(message+"\n")

    def getStandardButtons(self):
        return int(QtGui.QDialogButtonBox.Close)

    def reject(self):
        FreeCADGui.Control.closeDialog()
        if FreeCADGui.activeDocument():
            FreeCADGui.activeDocument().resetEdit()

class TemplateEditor(QtGui.QWidget):
    def __init__(self, parent=mw, form=None):
        super(TemplateEditor, self).__init__(parent, QtCore.Qt.Tool)
        self.form=form
        self.blockSignals = False
        self.setWindowTitle(f"Template editor v{__version__}")
        self.setAttribute(QtCore.Qt.WA_DeleteOnClose, True)
        self.layout = QtGui.QVBoxLayout()
        self.setLayout(self.layout)
        self.templateList = QtGui.QListWidget()
        self.templateList.currentItemChanged.connect(self.onTemplateListCurrentItemChanged)
        self.templateDict = {}
        topLine = QtGui.QHBoxLayout()
        topLine.addWidget(self.templateList)
        buttonBox = QtGui.QVBoxLayout()
        buttonBox.setAlignment(QtCore.Qt.AlignTop)
        topLine.addLayout(buttonBox)
        self.plusBtn = QtGui.QPushButton("+")
        buttonBox.addWidget(self.plusBtn)
        self.plusBtn.clicked.connect(self.onPlusBtnClicked)

        self.minusBtn = QtGui.QPushButton("-")
        buttonBox.addWidget(self.minusBtn)
        self.minusBtn.clicked.connect(self.onMinusBtnClicked)

        self.renameBtn = QtGui.QPushButton("Rename")
        buttonBox.addWidget(self.renameBtn)
        self.renameBtn.clicked.connect(self.onRenameBtnClicked)

        editLine = QtGui.QHBoxLayout()
        self.edit = QtGui.QPlainTextEdit()
        editLine.addWidget(self.edit)
        bottomButtonBox = QtGui.QVBoxLayout()
        bottomButtonBox.setAlignment(QtCore.Qt.AlignTop)
        editLine.addLayout(bottomButtonBox)

        self.testBtn = QtGui.QPushButton("Test")
        self.testBtn.clicked.connect(self.onTestBtnClicked)
        bottomButtonBox.addWidget(self.testBtn)

        self.executeBtn = QtGui.QPushButton("Execute")
        self.executeBtn.clicked.connect(self.onExecuteBtnClicked)
        bottomButtonBox.addWidget(self.executeBtn)

        self.executeToClipboardBtn = QtGui.QPushButton("Execute to\nclipboard")
        self.executeToClipboardBtn.setToolTip("Execute current template, but send text to clipboard")
        self.executeToClipboardBtn.clicked.connect(self.onExecuteToClipboardBtnClicked)
        bottomButtonBox.addWidget(self.executeToClipboardBtn)

        self.helpBtn = QtGui.QPushButton("Help")
        self.helpBtn.clicked.connect(self.onHelpBtnClicked)
        bottomButtonBox.addWidget(self.helpBtn)

        self.dlgButtonBox = QtGui.QDialogButtonBox(QtGui.QDialogButtonBox.Ok | QtGui.QDialogButtonBox.Cancel)
        self.applyBtn = QtGui.QPushButton("Apply")
        self.applyBtn.setToolTip("Apply changes, saves to templates file")
        self.applyBtn.clicked.connect(self.onApplyBtnClicked)
        self.dlgButtonBox.addButton(self.applyBtn, QtGui.QDialogButtonBox.ActionRole)
        self.dlgButtonBox.setCenterButtons(True)
        self.dlgButtonBox.accepted.connect(self.accept)
        self.dlgButtonBox.rejected.connect(self.reject)

        self.layout.addLayout(topLine)
        self.layout.addLayout(editLine)
        self.layout.addWidget(self.dlgButtonBox)
        self.resize(800,600)
        self.updateList()

    def updateList(self, fetch=True):
        self.templateList.clear()
        if fetch:
            self.templateDict = self.form.getTemplateString()
        self.blockSignals = True
        items=[]
        for k,v in self.templateDict.items():
            items.append(k)
        self.templateList.addItems(sorted(items))
        self.blockSignals = False
        if self.templateList.count():
            self.templateList.setCurrentRow(0)

    def setCurrentByName(self, name):
        if self.templateList.count() == 0:
            return
        match = 0
        for ii in range(self.templateList.count()):
            if self.templateList.item(ii).text() == name:
                match = ii
                break
        idx = self.templateList.setCurrentRow(match)

    def setCurrentByRow(self, row):
        if self.templateList.count() == 0:
            return
        if self.templateList.count() <= row:
            self.templateList.setCurrentRow(self.templateList.count()-1)
        else:
            self.templateList.setCurrentRow(row)

    def onExecuteToClipboardBtnClicked(self, arg1):
        """test current template"""
        curName = self.templateList.currentItem().text() if self.templateList.currentItem() else ""
        if not curName:
            return
        txt = self.edit.toPlainText()
        if not txt:
            return
        clipTxt = self.form.testTemplateItem(curName, txt)
        QtGui.QClipboard().setText(clipTxt)
        self.form.toast(f"{curName} to clipboard","Message")


    def onTestBtnClicked(self,arg1):
        """test current template"""
        curName = self.templateList.currentItem().text() if self.templateList.currentItem() else ""
        if not curName:
            return
        txt = self.edit.toPlainText()
        if not txt:
            return
        testTxt = "<pre>" + self.form.testTemplateItem(curName, txt) + "</pre>"
        QtGui.QMessageBox.information(self, f"{curName}", testTxt)

    def onExecuteBtnClicked(self, arg1):
        """execute current template"""
        curName = self.templateList.currentItem().text() if self.templateList.currentItem() else ""
        if not curName:
            return
        txt = self.edit.toPlainText()
        if not txt:
            return
        self.form.testTemplateItem(curName, txt, execute=True)

    def shallowCopy(self, fromDict):
        toDict = {}
        for k,v in fromDict.items():
            toDict[k] = v
        return toDict

    def onPlusBtnClicked(self, arg1):
        """add a new template item"""
        curName = self.templateList.currentItem().text() if self.templateList.currentItem() else ""
        curDict = {}
        if curName:
            curDict = self.shallowCopy(self.templateDict[curName])
        newTemplateName,ok = QtGui.QInputDialog.getText(self, "Add template","Enter name for new template:")
        if ok and newTemplateName:
            if newTemplateName in self.templateDict:
                self.form.print(f"{newTemplateName} already exists","Error")
                return
            if not curName:
                self.templateDict[newTemplateName] = {"label" : "input","name" : "input","output" : "name = QtGui.QPushButton('label')"}
            else:
                self.templateDict[newTemplateName] = curDict
            self.updateList(fetch=False)
            self.setCurrentByName(newTemplateName)

    def onMinusBtnClicked(self, arg1):
        curName = self.templateList.currentItem().text() if self.templateList.currentItem() else ""
        if not curName:
            return
        curRow = self.templateList.currentRow()
        self.templateDict.pop(curName)
        self.blockSignals = True
        self.updateList(fetch=False)
        self.blockSignals = False
        self.setCurrentByRow(curRow)
        if self.templateList.count() == 0:
            self.blockSignals = True
            self.templateList.addItem("template")
            self.edit.setPlainText("{}")
            self.templateDict = {"template":{"label":"input","name":"input","output":"name = QtGui.QPushButton('label')"}}
            self.blockSignals = False
            self.setCurrentByRow(0)

    def onHelpBtnClicked(self, arg1):
        helpText = """<pre>
Templates are a way to insert text into the current editor
at the current cursor position.  The templates are stored
in memory as a python dictionary of dictionaries.  In the
simplest case the text is copied directly into the editor,
but some text may also be replaced during execution.

The template item dictionary must contain a key named
"output".  This key contains the text to be inserted.
It can also hold some special values:

"input" -- user types in value for output in dialog.
"input1" -- like "input", but a single line edit.
"clipboard" -- output text comes from clipboard.
"selection" -- output text comes from current selection.
Any other value means use that value as the output text.

If "output" contains text matching the name of one of
the other keys, then that text gets replaced, depending
on the key's value:

'input' -- replacement text from multiple line QInputDialog
'input1' -- like input, but use single line dialog
'selection' -- taken from selection in current editor
'clipboard' -- replacement text is from the system clipboard
'find' -- replacement text is from the Find QLineEdit
'replace' -- replacement text is from the Replace QLineEdit
Any other value means use that value as the replacement text.

The "goto" key, if it exists, positions the cursor before the 
text is inserted.  The "goto" key can have these values:

'input' (or 'input1') -- line is from single line QInputDialog
'home' -- position cursor at start of line 1
'end' -- position cursor at end of document
'current' or '' -- ignore and use current cursor position
'42' -- example, go to line 42 and insert output there
'relative:7' -- example, go 7 lines down from current
'relative:-3' -- example, go 3 lines up from current
</pre>
"""
        QtGui.QMessageBox.information(self, "Help", helpText)

    def onRenameBtnClicked(self, arg1):
        curName = self.templateList.currentItem().text() if self.templateList.currentItem() else ""
        if not curName:
            return
        newName,ok = QtGui.QInputDialog.getText(self, "Editor assisant", f"Enter new name for {curName}",text=curName)
        if ok:
            if newName in self.templateDict:
                self.form.toast(f"{newName} already in dictionary","Error")
                return
            self.templateDict[newName] = {}
            for k,v in self.templateDict[curName].items():
                self.templateDict[newName][k] = v 
            self.templateDict.pop(curName)
            self.blockSignals = True
            self.updateList(fetch=False)
            self.blockSignals = False
            self.setCurrentByName(newName)

    def updateParameters(self):
        """update parameter string"""
        self.form.setTemplateString(self.templateDict)

    def updateDict(self, name, templateItemText):
        templateItem = json.loads(templateItemText,strict=False)
        self.templateDict[name] = templateItem

    def onTemplateListCurrentItemChanged(self, current, previous):
        if not self.templateList.count():
            return
        if self.blockSignals:
            return
        if previous:
            self.updateDict(previous.text(), self.edit.toPlainText())
        if current:
            self.updateEdit(current.text())

    def updateEdit(self, name):
        txt = self.formatTemplate(self.templateDict[name])
        self.edit.setPlainText(txt)

    def formatTemplate(self,template):
        """formats a single dictionary template, returns formatted string"""
        formatted = json.dumps(template,indent=0,separators=(','+chr(10),':'+chr(10)))
        formatted = formatted.replace('\\n',chr(10))
        #formatted = formatted.replace("{","{\n")
        #formatted = formatted.replace("}","\n}")
        #formatted = formatted.replace("\",","\",\n")
        return formatted

    def onApplyBtnClicked(self, arg1):
        self.updateDict(self.templateList.currentItem().text(),self.edit.toPlainText())
        self.updateParameters()

    def accept(self):
        self.updateDict(self.templateList.currentItem().text(),self.edit.toPlainText())
        self.updateParameters()
        self.close()

    def reject(self):
        self.close()


class DiffSaver (QtGui.QDialog):
    def __init__(self, parent=mw, form=None, plainText=None, snapText=None, label1=None, label2=None):
        super(DiffSaver, self).__init__(parent, QtCore.Qt.Tool)
        self.form=form
        self.slider=None
        self.webView=None
        self.widthSlider=None
        self.contextCheckBox = None
        self.numlinesSpinBox = None
        self.plainText = plainText
        self.snapText = snapText
        self.label1 = label1
        self.label2 = label2
        self.diff = ""
        self.makeDiff()
        self.blockSignals = False


    def setMaxWidthString(self, width=None):
        if not self.webView:
            return
        colWidth = width if width else self.width()/2-70
        MAXWIDTH=f"{colWidth}" #chr(123) = {, 125 = }
        width_string= f"<style>table td {chr(123)}overflow:auto;max-width:{MAXWIDTH}px;word-wrap:break-word;{chr(125)}</style></head>"
        new_diff = self.diff.replace("</head>",width_string)
        self.webView.setHtml(new_diff)

    def onContextCheckBoxStateChanged(self, arg1):
        self.makeDiff()
        self.setMaxWidthString()

    def onNumlinesSpinBoxValueChanged(self, val):
        self.makeDiff()
        self.setMaxWidthString()

    def makeDiff(self):
        """make the diff, expensive operation should only be done when necessary"""
        d = difflib.HtmlDiff(tabsize=4)
        numlines2 = 5 if not self.numlinesSpinBox else self.numlinesSpinBox.value()
        context2 = self.contextCheckBox.checkState() if self.contextCheckBox else True
        self.diff = d.make_file(fromlines = self.snapText, tolines = self.plainText, fromdesc = self.label1, todesc = self.label2, context=context2, numlines=numlines2)

    def updateTitle(self):
        if self.widthSlider and self.slider:
            self.setWindowTitle(f"Ea v{__version__} Diff Saver zoom:{self.slider.value()}%; Col width: {self.widthSlider.value()}px")

    def onResize(self, event):
        self.blockSignals = True
        width = self.width()/2-70
        self.widthSlider.setValue(width)
        self.setColWidth(width)

    def onSliderValueChanged(self, value):
        if self.blockSignals:
            self.blockSignals = False
            return
        self.webView.setZoomFactor(value/100.0)
        self.updateTitle()

    def saveDiffToHtml(self):
        fname = QtGui.QFileDialog.getSaveFileName(FreeCADGui.getMainWindow(),"Save diff to html file",filter='*.html')[0]
        if not fname:
            return
        with open(fname,"w") as outfile:
            outfile.write(self.diff)
        self.form.toast(f"Diff saved to {fname}","Message")

    def setColWidth(self, value):
        self.setMaxWidthString(value)
        self.updateTitle()

    def onWidthSliderValueChanged(self, value):
        self.setColWidth(value)


class Dockable (QtGui.QDockWidget):
    def __init__(self, parent=mw):
        super(Dockable,self).__init__(parent, QtCore.Qt.Tool)
        self.dlg = TaskEditorAssistant()
        self.setObjectName("Editor assistant dockwidget")
        QtGui.QDockWidget.setWindowIcon(self, QIconFromXPMString(__icon__))
        self.setWidget(self.dlg.form)
        self.setWindowTitle(f"Editor assistant v{__version__}")
        self.setAttribute(QtCore.Qt.WA_DeleteOnClose, True)

def QIconFromXPMString(xpm_string):
    xpm = xpm_string.replace("\"","").replace(',','').splitlines()[4:-1]
    pixmap = QtGui.QPixmap(xpm)
    icon = QtGui.QIcon(pixmap)
    return icon

def QIconFromStandard(name):
    pixmap = getattr(QtGui.QStyle,name)
    icon = QtGui.QPushButton().style().standardIcon(pixmap)
    return icon

def showEditorAssistantAsDockWidget():
    dockWidget = Dockable(mw)
    #dockWidget.show()
    mw.addDockWidget(QtCore.Qt.LeftDockWidgetArea, dockWidget)

def showEditorAssistantDialog():
    '''show the editor assistant dialog'''
    #dlg = TaskEditorAssistant()
    #dw = Dockable(mw)
    dlg = TaskEditorAssistant()
    comboView = mw.findChild(QtGui.QDockWidget,"Combo View")
    tabWidget = None
    if comboView:
        tabWidget = comboView.findChild(QtGui.QTabWidget)
    if tabWidget:
        tabWidget.addTab(dlg.form,f"Editor assistant v{__version__}")
        dlg.isTabbed = True
        tabWidget.setCurrentWidget(dlg.form)
        if not comboView.isVisible():
            FreeCAD.Console.PrintWarning("Editor assistant: Making Combo View visible\n")
            FreeCAD.Console.PrintMessage("Tip: press Alt while executing to open as dockable widget\n")
            comboView.setVisible(True)
    elif not FreeCADGui.Control.activeDialog():
        FreeCADGui.Control.showDialog(dlg.form)
    else:
        FreeCAD.Console.PrintError("Another task dialog is active.  Showing as dockable widget instead.\n")
        showEditorAssistantAsDockWidget()

__icon__="""
/* XPM */
static char *_647719150564[] = {
/* columns rows colors chars-per-pixel */
"64 64 7 1 ",
"  c black",
". c #EDED1C1C2424",
"X c #2222B1B14C4C",
"o c #FFFFC9C90E0E",
"O c #3F3F4848CCCC",
"+ c #DFDFDFDFDFDF",
"@ c None",
/* pixels */
"                                                   @@@@@@@@@@@@@",
"                                                   @@@@@@@@@@@@@",
"                                                    @@@@@@@@@@@@",
"                                                     @@@@@@@@@@@",
"    ++++++++++++++++++++++++++++++++++++++++++++      @@@@@@@@@@",
"    ++++++++++++++++++++++++++++++++++++++++++++       @@@@@@@@@",
"    ++++++++++++++++++++++++++++++++++++++++++++        @@@@@@@@",
"    ++++++++++++++++++++++++++++++++++++++++++++   +     @@@@@@@",
"    ++++++++++++++++++++++++++++++++++++++++++++   ++     @@@@@@",
"    ++++++++++++++++++++++++++++++++++++++++++++   +++     @@@@@",
"    ++++++++++++++++++++++++++++++++++++++++++++   ++++     @@@@",
"    ++++++++++++++++++++++++++++++++++++++++++++   +++++     @@@",
"    ++++++++++++++++++++++++++++++++++++++++++++   ++++++     @@",
"    ++++++++++++++++++++++++++++++++++++++++++++   +++++++     @",
"    ++++++++++++++++++++++++++++++++++++++++++++   ++++++++    @",
"    +++++++OOOOOOOOOOOXXXXXXXXXX          ++++++                ",
"    +++++++OOOOOOOOOOOXXXXXXXXXX          ++++++                ",
"    +++++++OOOOOOOOOOOXXXXXXXXXX          ++++++                ",
"    +++++++OOOOOOOOOOOXXXXXXXXXX          ++++++++++++++++++    ",
"    +++++++OOOOOOOOOOOXXXXXXXXXX          ++++++++++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    +++++++ooooo        ............         XXXXX++++++++++    ",
"    +++++++ooooo        ............         XXXXX++++++++++    ",
"    +++++++ooooo        ............         XXXXX++++++++++    ",
"    +++++++ooooo        ............         XXXXX++++++++++    ",
"    +++++++ooooo        ............         XXXXX++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    +++++++     XXXXXXXXXXXXXXOOOOOXXXXXXXXX      ++++++++++    ",
"    +++++++     XXXXXXXXXXXXXXOOOOOXXXXXXXXX      ++++++++++    ",
"    +++++++     XXXXXXXXXXXXXXOOOOOXXXXXXXXX      ++++++++++    ",
"    +++++++     XXXXXXXXXXXXXXOOOOOXXXXXXXXX      ++++++++++    ",
"    +++++++     XXXXXXXXXXXXXXOOOOOXXXXXXXXX      ++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    +++++++.......             ooooooOOOOOOOOOOOOO++++++++++    ",
"    +++++++.......             ooooooOOOOOOOOOOOOO++++++++++    ",
"    +++++++.......             ooooooOOOOOOOOOOOOO++++++++++    ",
"    +++++++.......             ooooooOOOOOOOOOOOOO++++++++++    ",
"    +++++++.......             ooooooOOOOOOOOOOOOO++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++    ",
"                                                                ",
"                                                                ",
"                                                                ",
"                                                                "
};

"""

undo_icon = """
/* XPM */
static char *edit_undo_XPM[] = {
/* columns rows colors chars-per-pixel */
"64 64 7 1",
"   c None",
".  c #FF8000",
"+  c #FFFF80",
"@  c #666666",
"#  c #FFFF00",
"$  c #FF8080",
"%  c None",
/* pixels */
"                                                                ",
"                                                                ",
"                            ..                                  ",
"                            ...                                 ",
"                          .....                                 ",
"                         ......                                 ",
"                        ...+...                                 ",
"                        ..++...                                 ",
"                      ...+++...                                 ",
"                     ...++++...                                 ",
"                    ...+++++...                                 ",
"                    ..++++++...                                 ",
"                  ...+++++++...                                 ",
"                ....++++++++...                                 ",
"               ...++++++++++...                                 ",
"              ...+++++++++++.@.                                 ",
"             ...++++++++++++...........                         ",
"            ...+++++++++++++.+++++++.....                       ",
"           ...++++++++++++++++++++++++++....                    ",
"          ...+++++++++++++++++++#+++++++....                    ",
"         ...++++++++++++++++++########+++++...                  ",
"        ...++++++++++++++++++##########+++++...                 ",
"       ...+++++++++++++++++##############++++...                ",
"      ....++++++++++++++++################++++..                ",
"      ...+++++++++++++++####################+++...              ",
"      ....++++++++++++++####################++++...             ",
"       ....++++++++++++######################+++#...            ",
"         ...+++++++++++#######################++##..            ",
"          ...+++++++++##########################++..            ",
"           ...+++++++#######++++++++############++..            ",
"            ...++++#########++++++++++++########++..            ",
"             ....+++########++....++++++########+++.            ",
"                ..++++######++.. .....++++#######++...          ",
"                ...++++#####++..  .....++++######++...          ",
"                 ...++++####++..     ...++++#####++...          ",
"                  ...+++####++..      ...+++#####++...          ",
"                   ...++++##++..        ..$+++###++...          ",
"                    ...++++#++..        ...+++###++...          ",
"                     ...++++++..         ..#++###++...          ",
"                      ...+++++..         ...++###++...          ",
"                        ..++++..          ..++###++...          ",
"                        %$.++#.$%   %  %  ..+++##++..           ",
"               %    %%  %%$.##.$%%%%%%%%  +.+++#+++.            ",
"              %%    %%% %%%....$%%%%%%%% %%.+++#+++.            ",
"            %%  %%%%%%%%%%%%....%%%%%%%%%%%.++##++..            ",
"           %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%.++#++#.. %%         ",
"        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%.++++++...%%%        ",
"        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%..++++...%%%%%        ",
"    %%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%..+++++..%%%%%         ",
"    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%..++++++.%%%%%%%%%% %%  ",
"   %%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%..++++++..%%%%%%%%%%%%%  ",
"  %%%%  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%...++++++..%%%%%%% %%%%    ",
"     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%..+++++++..%%%%%%%%% %%     ",
"     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%..++++++...%%%%%%%%%  %%     ",
"    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%..+++++...%%%%%%%%%%%%%%%     ",
"    %%%% %%%%%%%%%%%%%%%%%%%%%%%%..++++...%%%%%%%%% %%%%%%      ",
"         %%%%%%%%%%%%%%%%%%%%%%%%.......%%%%%%%%%%%%%%% %%      ",
"         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  %       ",
"         %%  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %           ",
"              %%  %%%%%%%%%%%%%%%%%%%%%%%%%%%  %%%              ",
"                 %%   %%%%  %%%%%%%% %%%                        ",
"                 %%    %%%% %%%%%%%%  %%                        ",
"                         %%     %                               ",
"                                                                "
};
"""
redo_icon = """
/* XPM */
static char *edit_redo_XPM[] = {
/* format */
"64 64 7 1",
"   c None",
".  c #FF8000",
"+  c #FFFF80",
"@  c #666666",
"#  c #FFFF00",
"$  c #FF8080",
"%  c None",
/* pixels */
"                                                                ",
"                                                                ",
"                                  ..                            ",
"                                 ...                            ",
"                                 .....                          ",
"                                 ......                         ",
"                                 ...+...                        ",
"                                 ...++..                        ",
"                                 ...+++...                      ",
"                                 ...++++...                     ",
"                                 ...+++++...                    ",
"                                 ...++++++..                    ",
"                                 ...+++++++...                  ",
"                                 ...++++++++....                ",
"                                 ...++++++++++...               ",
"                                 .@.+++++++++++...              ",
"                         ...........++++++++++++...             ",
"                       .....+++++++.+++++++++++++...            ",
"                    ....++++++++++++++++++++++++++...           ",
"                    ....+++++++#+++++++++++++++++++...          ",
"                  ...+++++########++++++++++++++++++...         ",
"                 ...+++++##########++++++++++++++++++...        ",
"                ...++++##############+++++++++++++++++...       ",
"                ..++++################++++++++++++++++....      ",
"              ...+++####################+++++++++++++++...      ",
"             ...++++####################++++++++++++++....      ",
"            ...#+++######################++++++++++++....       ",
"            ..##++#######################+++++++++++...         ",
"            ..++##########################+++++++++...          ",
"            ..++############++++++++#######+++++++...           ",
"            ..++########++++++++++++#########++++...            ",
"            .+++########++++++....++########+++....             ",
"          ...++#######++++..... ..++######++++..                ",
"          ...++######++++.....  ..++#####++++...                ",
"          ...++#####++++...     ..++####++++...                 ",
"          ...++#####+++...      ..++####+++...                  ",
"          ...++###+++$..        ..++##++++...                   ",
"          ...++###+++...        ..++#++++...                    ",
"          ...++###++#..         ..++++++...                     ",
"          ...++###++...         ..+++++...                      ",
"          ...++###++..          ..++++..                        ",
"           ..++##+++..  %  %   %$.#++.$%                        ",
"            .+++#+++.+  %%%%%%%%$.##.$%%  %%    %               ",
"            .+++#+++.%% %%%%%%%%$....%%% %%%    %%              ",
"            ..++##++.%%%%%%%%%%%....%%%%%%%%%%%%  %%            ",
"         %% ..#++#++.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%           ",
"        %%%...++++++.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        ",
"        %%%%%...++++..%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        ",
"         %%%%%..+++++..%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%    ",
"  %% %%%%%%%%%%.++++++..%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    ",
"  %%%%%%%%%%%%%..++++++..%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%   ",
"    %%%% %%%%%%%..++++++...%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  %%%%  ",
"     %% %%%%%%%%%..+++++++..%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     ",
"     %%  %%%%%%%%%...++++++..%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     ",
"     %%%%%%%%%%%%%%%...+++++..%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    ",
"      %%%%%% %%%%%%%%%...++++..%%%%%%%%%%%%%%%%%%%%%%%% %%%%    ",
"      %% %%%%%%%%%%%%%%%.......%%%%%%%%%%%%%%%%%%%%%%%%         ",
"       %  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%         ",
"           % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  %%         ",
"              %%%  %%%%%%%%%%%%%%%%%%%%%%%%%%%  %%              ",
"                        %%% %%%%%%%%  %%%%   %%                 ",
"                        %%  %%%%%%%% %%%%    %%                 ",
"                               %     %%                         ",
"                                                                "
};
"""
indent_icon = """
/* XPM */
static char *indent_xpm[] = {
/* format */
"64 64 9 1",
"   c None",
".  c black",
"+  c #DFDFDF",
"@  c #3F48CC",
"#  c green",
"$  c #3F48CC",
"%  c black",
"&  c #ED1C24",
"*  c #E2D9D6",
/* pixels */
"...................................................             ",
"...................................................             ",
"....................................................            ",
".....................................................           ",
"....++++++++++++++++++++++++++++++++++++++++++++......          ",
"....++++++++++++++++++++++++++++++++++++++++++++.......         ",
"....++++++++++++++++++++++++++++++++++++++++++++........        ",
"....++++++++++++++++++++++++++++++++++++++++++++...+.....       ",
"....++++++++++++++++++++++++++++++++++++++++++++...++.....      ",
"....++++++++++++++++++++++++++++++++++++++++++++...+++.....     ",
"....++++++++++++++++++++++++++++++++++++++++++++...++++.....    ",
"....++++++++++++++++++++++++++++++++++++++++++++...+++++.....   ",
"....++++++++++++++++++++++++++++++++++++++++++++...++++++.....  ",
"....++++++++++++++++++++++++++++++++++++++++++++...+++++++..... ",
"....++++++++++++++++++++++++++++++++++++++++++++...++++++++.... ",
"....+++++++%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%++++++................",
"....+++++++%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%++++++................",
"....+++++++%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%++++++................",
"....+++++++%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%++++++++++++++++++....",
"....+++++++%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%++++++++++++++++++....",
"....++++++++++++++++++++++++++++++++++++++++++++++++++++++++....",
"....++++++++++++++++++++++++++++++++++++++++++++++++++++++++....",
"....++++++++++++++++++++++++++++++++++++++++++++++++++++++++....",
"....++++++++++++++++++++++++++++++++++++++++++++++++++++++++....",
"....+++....+++++++++++++++++++++++++++++++++++++++++++++++++....",
"....+++.....++++++++++++++++++++++++++++++++++++++++++++++++....",
"....+++..$$..++++++++++++++++++++%%%%%%%%%%%%%%%%%%%%%%%%%++....",
"....+++..$$$...++++++++++++++++++%%%%%%%%%%%%%%%%%%%%%%%%%++....",
"....+++..$$$$$...++++++++++++++++%%%%%%%%%%%%%%%%%%%%%%%%%++....",
"....++++..$$$$$$...++++++++++++++%%%%%%%%%%%%%%%%%%%%%%%%%++....",
"....+++++..$$$$$$$...++++++++++++%%%%%%%%%%%%%%%%%%%%%%%%%++....",
"....+++++++..$$$$$$$...+++++++++++++++++++++++++++++++++++++....",
"....+++++++++..$$$$$$...++++++++++++++++++++++++++++++++++++....",
"....+++++++++++..$$$$$$..+++++++++++++++++++++++++++++++++++....",
"....+++++++++++++..$$$$$$..+++++++++++++++++++++++++++++++++....",
"....+++++++++++++++..$$$$$..++++++++++++++++++++++++++++++++....",
"....+++++++++++++++++..$$$$..+++++++++++++++++++++++++++++++....",
"....++++++++++++++++++..$$$$..+++%%%%%%%%%%%%%%%%%%%%%%%%%++....",
"....++++++++++++++++++..$$$$..+++%%%%%%%%%%%%%%%%%%%%%%%%%++....",
"....++++++++++++++++++..$$$$..+++%%%%%%%%%%%%%%%%%%%%%%%%%++....",
"....++++++++++++++++..$$$$$..++++%%%%%%%%%%%%%%%%%%%%%%%%%++....",
"....+++++++++++++++..$$$$$..+++++%%%%%%%%%%%%%%%%%%%%%%%%%++....",
"....+++++++++++++..$$$$$$..+++++++++++++++++++++++++++++++++....",
"....+++++++++++..$$$$$$$..++++++++++++++++++++++++++++++++++....",
"....+++++++++..$$$$$$$..++++++++++++++++++++++++++++++++++++....",
"....+++++++..$$$$$$$$..+++++++++++++++++++++++++++++++++++++....",
"....+++++..$$$$$$$$..+++++++++++++++++++++++++++++++++++++++....",
"....++++..$$$$$$$..+++++++++++++++++++++++++++++++++++++++++....",
"....+++..$$$$$$..++++++++++++++++%%%%%%%%%%%%%%%%%%%%%%%%%++....",
"....+++..$$$$..++++++++++++++++++%%%%%%%%%%%%%%%%%%%%%%%%%++....",
"....+++..$$$..+++++++++++++++++++%%%%%%%%%%%%%%%%%%%%%%%%%++....",
"....+++.....+++++++++++++++++++++%%%%%%%%%%%%%%%%%%%%%%%%%++....",
"....++++...++++++++++++++++++++++%%%%%%%%%%%%%%%%%%%%%%%%%++....",
"....++++++++++++++++++++++++++++++++++++++++++++++++++++++++....",
"....++++++++++++++++++++++++++++++++++++++++++++++++++++++++....",
"....++++++++++++++++++++++++++++++++++++++++++++++++++++++++....",
"....++++++++++++++++++++++++++++++++++++++++++++++++++++++++....",
"....++++++++++++++++++++++++++++++++++++++++++++++++++++++++....",
"....++++++++++++++++++++++++++++++++++++++++++++++++++++++++....",
"....++++++++++++++++++++++++++++++++++++++++++++++++++++++++....",
"................................................................",
"................................................................",
"................................................................",
"................................................................"};

"""
replace_icon = """
/* XPM */
static char *_647894170722[] = {
/* columns rows colors chars-per-pixel */
"64 64 9 1 ",
"  c black",
". c #2B0000",
"X c #2B2B00",
"o c gray17",
"O c #552B2B",
"+ c #3F48CC",
"@ c #C3C3C3",
"# c #FFFFD4",
"$ c None",
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$@@@@@@@@$$$$$$$$$$$$$$",
"$$$$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$$@@@@@@@@$$$$$$$$$$$$$$",
"$$$$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$$@@    @@$$$$$$$$$$$$$$",
"$$$$@@@@@@@@@@@+++++++++++++++++++++++@@$$@@    @@$$$$$$$$$$$$$$",
"$$$$@@@@@@@@@@++++++++++++++++++++++++@@$$@@    @@$$$$$$$$$$$$$$",
"$$$$@@@@@@@@@+++++++++++++++++++++++++@@$$@@    @@$$$$$$$$$$$$$$",
"$$$$@@@@@@@@++++++++++++++++++++++++++@@$$@@    @@$$$$$$$$$$$$$$",
"$$$$@@@@@@@@++++++++++++++++++++++++++@@$$@@    @@@@@@@@@@@@@$$$",
"$$$$@@@@@@@+++++++++++++++++++++++++++@@$$@@    @@@@@@@@@@@@@$$$",
"$$$$@@@@@@++++++++++++++++++++++++++++@@$$@@               @@$$$",
"$$$$@@@@@+++++++++++@@@@@@@@@@@@@@@@@@@@$$@@               @@$$$",
"$$$$@@@@@++++++++++@@@@@@@@@@@@@@@@@@@@@$$@@               @@$$$",
"$$$$@@@@@+++++++++@@@@@@$$$$$$$$$$$$$$$$$$@@    @@@@@@@@   @@$$$",
"$$$$@@@@@++++++++@@@@@@@$$$$$$$$$$$$$$$$$$@@    @@@@@@@@   @@$$$",
"$$$$@@@@@++++++++@@@@@@@$$$$$$$$$$$$$$$$$$@@    @@@@@@@@   @@#$$",
"$$$$@@@@++++++++++@@@@@@$$$$$$$$$$$$$$$$$$@@    @@@@@@@@   @@#$$",
"$$$$@@@++++++++++++@@@@@$$$$$$$$$$$$$$$$$$@@    @@@@@@@@   @@#$$",
"$$$$@++++++++++++++++@@@$$$$$$$$$$$$$$$$$$@@    @@@@@@@@   @@$$$",
"$$$$@+++++++++++++++++@@$$$$$$$$$$$$$$$$$$@@    @@@@@@@@   @@$$$",
"$$$$@+++++++++++++++++@@$$$$$$$$$$$$$$$$$$@@    @@@@@@@@   @@$$$",
"$$$$@@@++++++++++++@@@@@$$$$$$$$$$$$$$$$$$@@               @@$$$",
"$$$$@@@++++++++++++@@@@@$$$$$$$$$$$$$$$$$$@@               @@$$$",
"$$$$@@@++++++++++++@@@@@$$$$$$$$$$$$$$$$$$@@               @@$$$",
"$$$$@@@@+++++++++++@@@@@$$$$$$$$$$$$$$$$$$@@@@@@@@@@@@@@@@@@@$$$",
"$$$$@@@@++++++++++@@@@@@$$$$$$$$$$$$$$$$$$@@@@@@@@@@@@@@@@@@@$$$",
"$$$$@@@@++++++++++@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$@@@@++++++++++@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$@@@@@++++++++@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$@@@@@++++++++@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$@@@@@++++++++@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$@@@@@@++++++@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$@@@@@@++++++@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$@@@@@@++++++@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$@@@@@@@++++@@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$@@@@@@@++++@@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$@@@@@@@@++@@@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$@@@@@@@@@@@@@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$@@@@@@@@@@@@@@@@@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$@@@@@@@@@    XO@@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$@@@@@@          .@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$@@@@@             @@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$@@@@               @@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$@@@      @@@@@     .@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$@@      @@@@@@      @@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$@@     .@@@@@@@     @@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$@@     @@@@@@@@@@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$@@     @@@@@@@@@@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$@@     @@@@@@@@@@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$@@     @@@@@@@@@@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$@@     @@@@@@@@@@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$@@      @@@@@@@     @@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$@@@      @@@@@      @@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$@@@                @@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$@@@@              @@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$@@@@@@           @@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$@@@@@@@@o    .o@@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$@@@@@@@@@@@@@@@@@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$@@@@@@@@@@@@@@@@@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$"
};

"""
find_previous_icon = """
/* XPM */
static char *_647896432515[] = {
/* columns rows colors chars-per-pixel */
"64 64 8 1 ",
"  c black",
". c #ED1C24",
"X c #22B14C",
"o c #FFC90E",
"O c #3F48CC",
"+ c #7A82DC",
"@ c #DFDFDF",
"# c None",
"################################################################",
"################################################################",
"#######                            #############################",
"######                               ###########################",
"#####   @@@@@@@@@@@@@@@@              ##########################",
"####  @ @@@@@@@@@@@@@@@                 ########################",
"###  @@ @@@@@@@@@@@@@@                   #######################",
"##  @@@ @@@@@@@@@@@@@@       +++++       #######################",
"#  @@@@ @@@@@@@@@@@@@       +++++++       ######################",
"        @@@     XXXXX     ++++++++++      ######################",
"        @@@     XXXX      +++++++++++      #####################",
"  @@@@@@@@@     XXXX     +++++++++++++     #####################",
"  @@@@@@@@@@@@@@@@@      +++++++++++++      ####################",
"  @@@@@@@@@@@@@@@@@     +++++++++++++++     ####################",
"  @@@@@@@@@@@@@@@@@     +++++++++++++++     ####################",
"  @@@@@XXX    ....     +++++++++++++++++     ###################",
"  @@@@@XXX    ....     +++++++++++++++++     ###################",
"  @@@@@@@@@@@@@@@@     +++++++++++++++++     ###################",
"  @@@@@@@@@@@@@@@@     +++++++++++++++++     ###################",
"  @@@@@@@@@@@@@@@@     +++++++++++++++++     ###################",
"  @@@@@   XXXXXOOX     +++++++++++++++++     ###################",
"  @@@@@   XXXXXOOX     +++++++++++++++++     ###################",
"  @@@@@   XXXXXOOX     +++++++++++++++++     ###################",
"  @@@@@@@@@@@@@@@@@     +++++++++++++++     ###############OOO##",
"  @@@@@@@@@@@@@@@@@     +++++++++++++++     ##############OOOOO#",
"  @@@@@@@@@@@@@@@@@     +++++++++++++++     ##############OOOOO#",
"  @@@@@OOOOOOOooo        +++++++++++++      ############OOOOOOO#",
"  @@@@@OOOOOOOooo         +++++++++++      ############OOOOOOOO#",
"  @@@@@@@@@@@@@@@@@@      +++++++++++      ############OOOOOOO##",
"  @@@@@@@@@@@@@@@@@@@      +++++++++      #############OOOOOOO##",
"  @@@@@@@@@@@@@@@@@@@        +++++       ##############OOOOOOO##",
"  @@@@@@@@@@@@@@@@@@@@                   ##############OOOOOOO##",
"                                        ##############OOOOOOOO##",
"                                      ################OOOOOOOO##",
"##########################           #################OOOOOOO###",
"############################       ###################OOOOOOO###",
"#############################     ####################OOOOOOO###",
"#############################     ###################OOOOOOOO###",
"#############################     ###################OOOOOOOO###",
"#############################     ###################OOOOOOOO###",
"#############################     ###################OOOOOOOO###",
"#############################     ##################OOOOOOOO####",
"#############################     #################OOOOOOOOO####",
"#############################     #################OOOOOOOOO####",
"#############################     ###############OOOOOOOOOOO####",
"#############################     #############OOOOOOOOOOOO#####",
"#####################OOO######################OOOOOOOOOOOOO#####",
"##################OOOOOOO####################OOOOOOOOOOOOO######",
"##############OOOOOOOOOOOO##################OOOOOOOOOOOOOO######",
"###########OOOOOOOOOOOOOOO##################OOOOOOOOOOOOO#######",
"########OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO########",
"####OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO########",
"###OOOOOOOOOOOOOOO###OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO#########",
"##OOOOOOOOOOOOO#######OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO##########",
"##OOOOOOOOOOOOO#######OOOOOOOOOOOOOOOOOOOOOOOOOOOOOO############",
"###OOOOOOOOOOOOOOO###OOOOOOOOOOOOOOOOOOOOOOOOOOOOOO#############",
"####OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO##############",
"#######OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO################",
"###########OOOOOOOOOOOOOOOO#####################################",
"##############OOOOOOOOOOOO######################################",
"#################OOOOOOOO#######################################",
"#####################OOO########################################",
"################################################################",
"################################################################"
};
"""
find_next_icon = """
/* XPM */
static char *_647896407113[] = {
/* columns rows colors chars-per-pixel */
"64 64 8 1 ",
"  c black",
". c #ED1C24",
"X c #22B14C",
"o c #FFC90E",
"O c #3F48CC",
"+ c #7A82DC",
"@ c #DFDFDF",
"# c None",
"################################################################",
"################################################################",
"#############################           ########################",
"###########################                               ######",
"##########################              @@@@@@@@@@@@@@@@   #####",
"########################                 @@@@@@@@@@@@@@@ @  ####",
"#######################                   @@@@@@@@@@@@@@ @@  ###",
"#######################       +++++       @@@@@@@@@@@@@@ @@@  ##",
"######################       +++++++       @@@@@@@@@@@@@ @@@@  #",
"######################      ++++++++++     XXXXX     @@@        ",
"#####################      +++++++++++      XXXX     @@@        ",
"#####################     +++++++++++++     XXXX     @@@@@@@@@  ",
"####################      +++++++++++++      @@@@@@@@@@@@@@@@@  ",
"####################     +++++++++++++++     @@@@@@@@@@@@@@@@@  ",
"####################     +++++++++++++++     @@@@@@@@@@@@@@@@@  ",
"###################     +++++++++++++++++     ....    XXX@@@@@  ",
"###################     +++++++++++++++++     ....    XXX@@@@@  ",
"###################     +++++++++++++++++     @@@@@@@@@@@@@@@@  ",
"###################     +++++++++++++++++     @@@@@@@@@@@@@@@@  ",
"###################     +++++++++++++++++     @@@@@@@@@@@@@@@@  ",
"###################     +++++++++++++++++     XOOXXXXX   @@@@@  ",
"###################     +++++++++++++++++     XOOXXXXX   @@@@@  ",
"###################     +++++++++++++++++     XOOXXXXX   @@@@@  ",
"##OOO###############     +++++++++++++++     @@@@@@@@@@@@@@@@@  ",
"#OOOOO##############     +++++++++++++++     @@@@@@@@@@@@@@@@@  ",
"#OOOOO##############     +++++++++++++++     @@@@@@@@@@@@@@@@@  ",
"#OOOOOOO############      +++++++++++++        oooOOOOOOO@@@@@  ",
"#OOOOOOOO############      +++++++++++         oooOOOOOOO@@@@@  ",
"##OOOOOOO############      +++++++++++      @@@@@@@@@@@@@@@@@@  ",
"##OOOOOOO#############      +++++++++      @@@@@@@@@@@@@@@@@@@  ",
"##OOOOOOO##############       +++++        @@@@@@@@@@@@@@@@@@@  ",
"##OOOOOOO##############                   @@@@@@@@@@@@@@@@@@@@  ",
"##OOOOOOOO##############                                        ",
"##OOOOOOOO################                                      ",
"###OOOOOOO#################           ##########################",
"###OOOOOOO###################       ############################",
"###OOOOOOO####################     #############################",
"###OOOOOOOO###################     #############################",
"###OOOOOOOO###################     #############################",
"###OOOOOOOO###################     #############################",
"###OOOOOOOO###################     #############################",
"####OOOOOOOO##################     #############################",
"####OOOOOOOOO#################     #############################",
"####OOOOOOOOO#################     #############################",
"####OOOOOOOOOOO###############     #############################",
"#####OOOOOOOOOOOO#############     #####OOOO####################",
"#####OOOOOOOOOOOOO######################OOOO####################",
"######OOOOOOOOOOOOO####################OOOOOOOO#################",
"######OOOOOOOOOOOOOO##################OOOOOOOOOOOOO#############",
"#######OOOOOOOOOOOOOOO##############OOOOOOOOOOOOOOOOOO##########",
"########OOOOOOOOOOOOOOO###########OOOOOOOOOOOOOOOOOOOOOOO#######",
"########OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO####",
"#########OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO###OOOOOOOOOOOOOOO###",
"##########OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO#######OOOOOOOOOOOOO##",
"############OOOOOOOOOOOOOOOOOOOOOOOOOOOOOO#######OOOOOOOOOOOOO##",
"#############OOOOOOOOOOOOOOOOOOOOOOOOOOOOOO###OOOOOOOOOOOOOOO###",
"##############OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO####",
"################OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO#######",
"##################OOOOO############OOOOOOOOOOOOOOOOOO###########",
"######################################OOOOOOOOOOOOO#############",
"#######################################OOOOOOOOO################",
"########################################OOOO####################",
"########################################OOOO####################",
"################################################################"
};

"""
replace_all_icon = """
/* XPM */
static char *_647894950477[] = {
/* columns rows colors chars-per-pixel */
"64 64 9 1 ",
"  c black",
". c #2B0000",
"X c #2B2B00",
"o c gray17",
"O c #552B2B",
"+ c #3F48CC",
"@ c #C3C3C3",
"# c #FFFFD4",
"$ c None",
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$@@@@@@@@@$$$$$$$$$$$$$$",
"$$$$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$$$$$$$$$$$$$$",
"$$$$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@$$$$$$$$$$$$$$",
"$$$$@@@@@@@@@@@+++++++++++++++++++++++@@@@@@    @@$$$$$$$$$$$$$$",
"$$$$@@@@@@@@@@++++++++++++++++++++++++@@@@@@    @@$$$$$$$$$$$$$$",
"$$$$@@@@@@@@@+++++++++++++++++++++++++@@@@@@    @@$$$$$$$$$$$$$$",
"$$$$@@@@@@@@++++++++++++++++++++++++++@   @@    @@$$$$$$$$$$$$$$",
"$$$$@@@@@@@@++++++++++++++++++++++++++@   @@    @@@@@@@@@@@@@$$$",
"$$$$@@@@@@@++++++++++++@@@@@@@@@@@@@@@@   @@    @@@@@@@@@@@@@$$$",
"$$$$@@@@@@+++++++++++++@@@@@              @@               @@$$$",
"$$$$@@@@@+++++++++++@@@@@@@@              @@               @@$$$",
"$$$$@@@@@++++++++++@@@@@@@@@              @@               @@$$$",
"$$$$@@@@@+++++++++@@@@@@@@@@   @@@@@@@@   @@    @@@@@@@@   @@$$$",
"$$$$@@@@@++++++++@@@@@@@@@@@   @@@@@@@@   @@    @@@@@@@@   @@$$$",
"$$$$@@@@@++++++++@@@@@@@@@@@   @@@@@@@@   @@    @@@@@@@@   @@#$$",
"$$$$@@@@++++++++++@@@@@@@@@@   @@@@@@@@   @@    @@@@@@@@   @@#$$",
"$$$$@@@++++++++++++@@@@@@@@@   @@@@@@@@   @@    @@@@@@@@   @@#$$",
"$$$$@++++++++++++++++@@@@@@@   @@@@@@@@   @@    @@@@@@@@   @@$$$",
"$$$$@+++++++++++++++++@@@@@@   @@@@@@@@   @@    @@@@@@@@   @@$$$",
"$$$$@+++++++++++++++++@@@@@@   @@@@@@@@   @@    @@@@@@@@   @@$$$",
"$$$$@@@++++++++++++@@@@@@@@@              @@               @@$$$",
"$$$$@@@++++++++++++@@@@@@@@@              @@               @@$$$",
"$$$$@@@++++++++++++@@@@@@@@@              @@               @@$$$",
"$$$$@@@@+++++++++++@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$$$",
"$$$$@@@@++++++++++@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$$$",
"$$$$@@@@++++++++++@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$@@@@++++++++++@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$@@@@@++++++++@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$@@@@@++++++++@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$@@@@@++++++++@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$@@@@@@++++++@@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$@@@@@@++++++@@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$@@@@@@++++++@@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$@@@@@@@++++@@@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$@@@@@@@++++@@@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$@@@@@@@@++@@@@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$@@@@@@@@@@@@@@     @@@@@@@@@@@@@@@@@@@@@@@$$$$$$$$$$$$$$$$$$",
"$$@@@@@@@@@@@@@@@@     @@@@@@@@@@@@@@@@@@@@@@@$$$$$$$$$$$$$$$$$$",
"$$@@@@@@@@@      @     @@@@@@@@@@    XO@@@@@@@$$$$$$$$$$$$$$$$$$",
"$$@@@@@@               @@@@@@@          .@@@@@$$$$$$$$$$$$$$$$$$",
"$$@@@@@                @@@@@@             @@@@$$$$$$$$$$$$$$$$$$",
"$$@@@@                 @@@@@               @@@$$$$$$$$$$$$$$$$$$",
"$$@@@      @@@@@       @@@@      @@@@@     .@@$$$$$$$$$$$$$$$$$$",
"$$@@      @@@@@@       @@@      @@@@@@      @@$$$$$$$$$$$$$$$$$$",
"$$@@     .@@@@@@@      @@@     .@@@@@@@     @@$$$$$$$$$$$$$$$$$$",
"$$@@     @@@@@@@@@     @@@     @@@@@@@@@@@@@@@$$$$$$$$$$$$$$$$$$",
"$$@@     @@@@@@@@@     @@@     @@@@@@@@@@@@@@@$$$$$$$$$$$$$$$$$$",
"$$@@     @@@@@@@@@     @@@     @@@@@@@@@@@@@@@$$$$$$$$$$$$$$$$$$",
"$$@@     @@@@@@@@@     @@@     @@@@@@@@@@@@@@@$$$$$$$$$$$$$$$$$$",
"$$@@     @@@@@@@@@     @@@     @@@@@@@@@@@@@@@$$$$$$$$$$$$$$$$$$",
"$$@@      @@@@@@@      @@@      @@@@@@@     @@$$$$$$$$$$$$$$$$$$",
"$$@@@      @@@@@       @@@@      @@@@@      @@$$$$$$$$$$$$$$$$$$",
"$$@@@                  @@@@                @@@$$$$$$$$$$$$$$$$$$",
"$$@@@@                 @@@@@              @@@@$$$$$$$$$$$$$$$$$$",
"$$@@@@@@               @@@@@@@           @@@@@$$$$$$$$$$$$$$$$$$",
"$$@@@@@@@@     . @     @@@@@@@@@o    .o@@@@@@@$$$$$$$$$$$$$$$$$$",
"$$@@@@@@@@@@@@@@@@     @@@@@@@@@@@@@@@@@@@@@@@$$$$$$$$$$$$$$$$$$",
"$$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$$$$$$$$$$$$$$$$$$",
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$"
};
"""
unindent_icon = """
/* XPM */
static char * unindent_xpm[] = {
/* format */
"64 64 9 1",
"   c None",
"z  c #000000",
"+  c #DFDFDF",
"@  c #3F48CC",
"#  c #22B14C",
"x  c #3F48CC",
"%  c black",
"&  c #ED1C24",
"*  c #E2D9D6",
/* pixels */
"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz              ",
"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz             ",
"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz            ",
"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz           ",
"zzzz++++++++++++++++++++++++++++++++++++++++++++zzzzzz          ",
"zzzz++++++++++++++++++++++++++++++++++++++++++++zzzzzzz         ",
"zzzz++++++++++++++++++++++++++++++++++++++++++++zzzzzzzz        ",
"zzzz++++++++++++++++++++++++++++++++++++++++++++zzz+zzzzz       ",
"zzzz++++++++++++++++++++++++++++++++++++++++++++zzz++zzzzz      ",
"zzzz++++++++++++++++++++++++++++++++++++++++++++zzz+++zzzzz     ",
"zzzz++++++++++++++++++++++++++++++++++++++++++++zzz++++zzzzz    ",
"zzzz++++++++++++++++++++++++++++++++++++++++++++zzz+++++zzzzz   ",
"zzzz++++++++++++++++++++++++++++++++++++++++++++zzz++++++zzzzz  ",
"zzzz++++++++++++++++++++++++++++++++++++++++++++zzz+++++++zzzzz ",
"zzzz++++++++++++++++++++++++++++++++++++++++++++zzz++++++++zzzz ",
"zzzz+++++++%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%++++++zzzzzzzzzzzzzzzz",
"zzzz+++++++%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%++++++zzzzzzzzzzzzzzzz",
"zzzz+++++++%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%++++++zzzzzzzzzzzzzzzz",
"zzzz+++++++%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%++++++++++++++++++zzzz",
"zzzz+++++++%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%++++++++++++++++++zzzz",
"zzzz++++++++++++++++++++++++++++++++++++++++++++++++++++++++zzzz",
"zzzz++++++++++++++++++++++++++++++++++++++++++++++++++++++++zzzz",
"zzzz++++++++++++++++++++++++++++++++++++++++++++++++++++++++zzzz",
"zzzz++++++++++++++++++++++++++++++++++++++++++++++++++++++++zzzz",
"zzzz++++++++++++++++++++++++++++++++++++++++++++++++++++++++zzzz",
"zzzz+++++++++++++++++++++++++++++++++++++++++++++++++zz+++++zzzz",
"zzzz++++%%%%%%%%%%%%%%%%%%%%%%%%%+++++++++++++++++++zzzzz+++zzzz",
"zzzz++++%%%%%%%%%%%%%%%%%%%%%%%%%++++++++++++++++++zzxxzz+++zzzz",
"zzzz++++%%%%%%%%%%%%%%%%%%%%%%%%%++++++++++++++++zzxxxxzz+++zzzz",
"zzzz++++%%%%%%%%%%%%%%%%%%%%%%%%%++++++++++++++zzxxxxxxzz+++zzzz",
"zzzz++++%%%%%%%%%%%%%%%%%%%%%%%%%++++++++++++zzxxxxxxxzz++++zzzz",
"zzzz+++++++++++++++++++++++++++++++++++++++zzxxxxxxxxzz+++++zzzz",
"zzzz++++++++++++++++++++++++++++++++++++++zzxxxxxxxxzz++++++zzzz",
"zzzz++++++++++++++++++++++++++++++++++++zzxxxxxxxxzz++++++++zzzz",
"zzzz+++++++++++++++++++++++++++++++++++zzxxxxxxxzz++++++++++zzzz",
"zzzz+++++++++++++++++++++++++++++++++zzxxxxxxxzz++++++++++++zzzz",
"zzzz++++++++++++++++++++++++++++++++zzxxxxxxzz++++++++++++++zzzz",
"zzzz++++%%%%%%%%%%%%%%%%%%%%%%%%%++zzxxxxxxzz+++++++++++++++zzzz",
"zzzz++++%%%%%%%%%%%%%%%%%%%%%%%%%++zzxxxxzz+++++++++++++++++zzzz",
"zzzz++++%%%%%%%%%%%%%%%%%%%%%%%%%++zzxxxxxzz++++++++++++++++zzzz",
"zzzz++++%%%%%%%%%%%%%%%%%%%%%%%%%+++zzxxxxxzzz++++++++++++++zzzz",
"zzzz++++%%%%%%%%%%%%%%%%%%%%%%%%%++++zzxxxxxxzz+++++++++++++zzzz",
"zzzz++++++++++++++++++++++++++++++++++zzxxxxxxxzz+++++++++++zzzz",
"zzzz+++++++++++++++++++++++++++++++++++zzzxxxxxxzzz+++++++++zzzz",
"zzzz+++++++++++++++++++++++++++++++++++++zzzxxxxxxzz++++++++zzzz",
"zzzz++++++++++++++++++++++++++++++++++++++zzzxxxxxxzz+++++++zzzz",
"zzzz+++++++++++++++++++++++++++++++++++++++zzzzxxxxxxzz+++++zzzz",
"zzzz+++++++++++++++++++++++++++++++++++++++++zzzzxxxxxxzz+++zzzz",
"zzzz++++%%%%%%%%%%%%%%%%%%%%%%%%%++++++++++++++zzzzxxxxzz+++zzzz",
"zzzz++++%%%%%%%%%%%%%%%%%%%%%%%%%+++++++++++++++++zzxxxxzz++zzzz",
"zzzz++++%%%%%%%%%%%%%%%%%%%%%%%%%++++++++++++++++++zzxxxzz++zzzz",
"zzzz++++%%%%%%%%%%%%%%%%%%%%%%%%%+++++++++++++++++++zzxxzz++zzzz",
"zzzz++++%%%%%%%%%%%%%%%%%%%%%%%%%++++++++++++++++++++zzzzz++zzzz",
"zzzz++++++++++++++++++++++++++++++++++++++++++++++++++zzz+++zzzz",
"zzzz++++++++++++++++++++++++++++++++++++++++++++++++++++++++zzzz",
"zzzz++++++++++++++++++++++++++++++++++++++++++++++++++++++++zzzz",
"zzzz++++++++++++++++++++++++++++++++++++++++++++++++++++++++zzzz",
"zzzz++++++++++++++++++++++++++++++++++++++++++++++++++++++++zzzz",
"zzzz++++++++++++++++++++++++++++++++++++++++++++++++++++++++zzzz",
"zzzz++++++++++++++++++++++++++++++++++++++++++++++++++++++++zzzz",
"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz",
"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz",
"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz",
"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"};
"""
snapshot_icon = """
/* XPM */
static char *_647898900207[] = {
/* columns rows colors chars-per-pixel */
"64 64 3 1 ",
"  c gray4",
". c gray85",
"X c None",
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
"XX..........................................................XXXX",
"XX..........................................................XXXX",
"XX..........................................................XXXX",
"XX..........................................................XXXX",
"XX..........................................................XXXX",
"XX....................                 .....................XXXX",
"XX....................                 .....................XXXX",
"XX....................                 .....................XXXX",
"XX..................                     ...................XXXX",
"XX..................                     ...................XXXX",
"XX.........                                       ..........XXXX",
"XX.......                                            .......XXXX",
"XX.....                                               ......XXXX",
"XX....                                                 .....XXXX",
"XX....                                                  ....XXXX",
"XX...                                                   ....XXXX",
"XX...                                                    ...XXXX",
"XX...                       ......                       ...XXXX",
"XX...                     ..........                     ...XXXX",
"XX...                   ..............                   ...XXXX",
"XX...                  ................                  ...XXXX",
"XX...                 ..................                 ...XXXX",
"XX...                 ...................                ...XXXX",
"XX...                .........   ........                ...XXXX",
"XX...                .......       ......                ...XXXX",
"XX...               ........       .......               ...XXXX",
"XX...               .......         ......               ...XXXX",
"XX...               .......         ......               ...XXXX",
"XX...               .......         ......               ...XXXX",
"XX...               ........       .......               ...XXXX",
"XX...                .......       .......               ...XXXX",
"XX...                .........   ........                ...XXXX",
"XX...                 ...................                ...XXXX",
"XX...                 ..................                 ...XXXX",
"XX...                  ................                  ...XXXX",
"XX...                   ..............                   ...XXXX",
"XX...                     ..........                     ...XXXX",
"XX...                       ......                       ...XXXX",
"XX...                                                    ...XXXX",
"XX...                                                   ....XXXX",
"XX...                                                   ....XXXX",
"XX....                                                  ....XXXX",
"XX.....                                                .....XXXX",
"XX......                                              ......XXXX",
"XX.......                                           ........XXXX",
"XX...........                                    ...........XXXX",
"XX..........................................................XXXX",
"XX..........................................................XXXX",
"XX..........................................................XXXX",
"XX..........................................................XXXX",
"XX..........................................................XXXX",
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
};
"""

match_case_icon = """
/* XPM */
static char *_647901377770[] = {
/* columns rows colors chars-per-pixel */
"64 64 3 1 ",
"  c black",
"z c #C3C3C3",
"x c None",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxzzzzzzzzzzzzzzxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxzzzzzzzzzzzzzzxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxzz          zzxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxzz           zzxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxzz           zzxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxzz             zzxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxzz             zzxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxzz              zzxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxzz               zzxxxxxxxxxxxzzzzzzzzzzzzzzzzzzzzxxxxx",
"xxxxxxxxxzz               zzxxxxxxxxxxxxzzzzzzzzzzzzzzzzzxxxxxxx",
"xxxxxxxxxzz       z        zzxxxxxxxxxxxzz           zzzzzxxxxxx",
"xxxxxxxxzz        z        zzxxxxxxxxzz                 zzzzxxxx",
"xxxxxxxxzz       zzz       zzxxxxxxxzz                   zzzxxxx",
"xxxxxxxxzz       zzz        zzxxxxxzz                    zzzxxxx",
"xxxxxxxzz        zzz        zzxxxxxzz                     zzxxxx",
"xxxxxxxzz        zzzz       zzxxxxzz         zzzzz        zzxxxx",
"xxxxxxzz        zzzzz        zzxxxxxzzzz    zzzzzzz       zzxxxx",
"xxxxxxzz        zzzzz        zzxxxxxzzzzzzzzzzzzzz        zzxxxx",
"xxxxxxzz        zzzzzz        zzxxxxxxxzzzzzz             zzxxxx",
"xxxxxzz                       zzxxxxxxzzz                 zzxxxx",
"xxxxxzz                       zzxxxxzz                    zzxxxx",
"xxxxxzz                        zzxxzz            zz       zzxxxx",
"xxxxzz                         zzxzz         zzzzzz       zzxxxx",
"xxxxzz                         zzxzz        zzzzzzz       zzxxxx",
"xxxxzz                          zzzz       zzzzzzz        zzxxxx",
"xxxzz                           zzzz        zzzzz         zzxxxx",
"xxxzz        zzzzzzzzzzz        zzzz                      zzxxxx",
"xxxzz        zzzzzzzzzzz         zzz                      zzxxxx",
"xxxzz        zzxxxxxxxzz         zzzz             z        zzxxx",
"xxxzz       zzxxxxxxxxxzz         zzzz           zzz       zzxxx",
"xxxzz       zzxxxxxxxxxzz         zzxxzz       zzzzz       zzxxx",
"xxzzzzzzzzzzzzxxxxxxxxxzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzxx",
"xxzzzzzzzzzzzzxxxxxxxxxzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
};
"""
match_whole_word_icon = """
/* XPM */
static char *_647901969918[] = {
/* columns rows colors chars-per-pixel */
"64 64 3 1 ",
"  c black",
"z c #C3C3C3",
"x c None",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz",
"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz",
"zz                                                            zz",
"zz                                                            zz",
"zz                                                            zz",
"zz                                                            zz",
"zz                                                            zz",
"zz                                                            zz",
"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz",
"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxzzzzzzzzzzzzzzxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxzzzzzzzzzzzzzzxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxzz          zzxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxzz           zzxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxzz           zzxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxzz             zzxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxzz             zzxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxzz              zzxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxzz               zzxxxxxxxxxxxzzzzzzzzzzzzzzzzzzzzxxxxx",
"xxxxxxxxxzz               zzxxxxxxxxxxxxzzzzzzzzzzzzzzzzzxxxxxxx",
"xxxxxxxxxzz       z        zzxxxxxxxxxxxzz           zzzzzxxxxxx",
"xxxxxxxxzz        z        zzxxxxxxxxzz                 zzzzxxxx",
"xxxxxxxxzz       zzz       zzxxxxxxxzz                   zzzxxxx",
"xxxxxxxxzz       zzz        zzxxxxxzz                    zzzxxxx",
"xxxxxxxzz        zzz        zzxxxxxzz                     zzxxxx",
"xxxxxxxzz        zzzz       zzxxxxzz         zzzzz        zzxxxx",
"xxxxxxzz        zzzzz        zzxxxxxzzzz    zzzzzzz       zzxxxx",
"xxxxxxzz        zzzzz        zzxxxxxzzzzzzzzzzzzzz        zzxxxx",
"xxxxxxzz        zzzzzz        zzxxxxxxxzzzzzz             zzxxxx",
"xxxxxzz                       zzxxxxxxzzz                 zzxxxx",
"xxxxxzz                       zzxxxxzz                    zzxxxx",
"xxxxxzz                        zzxxzz            zz       zzxxxx",
"xxxxzz                         zzxzz         zzzzzz       zzxxxx",
"xxxxzz                         zzxzz        zzzzzzz       zzxxxx",
"xxxxzz                          zzzz       zzzzzzz        zzxxxx",
"xxxzz                           zzzz        zzzzz         zzxxxx",
"xxxzz        zzzzzzzzzzz        zzzz                      zzxxxx",
"xxxzz        zzzzzzzzzzz         zzz                      zzxxxx",
"xxxzz        zzxxxxxxxzz         zzzz             z        zzxxx",
"xxxzz       zzxxxxxxxxxzz         zzzz           zzz       zzxxx",
"xxxzz       zzxxxxxxxxxzz         zzxxzz       zzzzz       zzxxx",
"xxzzzzzzzzzzzzxxxxxxxxxzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzxx",
"xxzzzzzzzzzzzzxxxxxxxxxzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzxx",
"xxzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz",
"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz",
"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz",
"zz                                                            zz",
"zz                                                            zz",
"zz                                                            zz",
"zz                                                            zz",
"zz                                                            zz",
"zz                                                            zz",
"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz",
"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
};
"""
children = mw.findChildren(QtGui.QWidget,"Editor assistant")
if not children:
    modifiers = QtGui.QApplication.keyboardModifiers()
    if modifiers == QtCore.Qt.AltModifier:
        showEditorAssistantAsDockWidget()
    else:
        showEditorAssistantDialog()
else:
    FreeCAD.Console.PrintError("Editor assistant already running\n")

